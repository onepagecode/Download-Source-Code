<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>06f22a44356e49c598543ef79fc87725</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="cell markdown">
<p><a
href="https://github.dev/Hvass-Labs/FinanceOps/blob/master/01E_Forecasting_US_Stock_Indices.ipynb"
class="uri">https://github.dev/Hvass-Labs/FinanceOps/blob/master/01E_Forecasting_US_Stock_Indices.ipynb</a></p>
</div>
<div class="cell markdown">
<p>We compared the historical returns of different stock indices for the
United States in a. Using the mathematical model from , this paper will
forecast future returns based on e.g. the P/Sales or P/Book ratios.
Based on their current P/S ratios, we can compare the forecasted returns
for the major U.S. stock indices. S&amp;P 500 (large-cap), S&amp;P 400
(mid-cap), S&amp;P 600 (small-cap), and NASDAQ 100 (mainly technology)
will be studied. This paper will summarize the main ideas again so it
can hopefully be read on its own. The previous papers provide detailed
explanations of the mathematics.</p>
</div>
<div class="cell markdown">
<p>Python version 2.7 is used to implement this Jupyter Notebook. For
numerical computations and plotting, it requires various packages.
README-file contains installation instructions.</p>
</div>
<div class="cell code" data-execution_count="1">
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span></code></pre></div>
</div>
<div id="1752e720" class="cell markdown">
<p>This code enables Jupyter Notebook, an interactive coding
environment, to display plots within the notebook rather than in a
separate window. It is a "magic command" that instructs the notebook to
render plots directly below the code cell. It allows data scientists and
programmers to visualize and analyze their data without switching
between different windows. When working with large datasets or comparing
multiple plots, this feature is especially useful.</p>
</div>
<div class="cell code" data-execution_count="2">
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Imports from Python packages.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.ticker <span class="im">import</span> FuncFormatter</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> ttest_rel, ttest_ind</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span></code></pre></div>
</div>
<div id="c4bfa2b4" class="cell markdown">
<p>The script begins by importing several Python packages. The
<code>matplotlib.pyplot</code> package provides a way to create plots
and graphs, the <code>matplotlib.ticker.FuncFormatter</code> package
allows for the formatting of tick marks on plots, the
<code>scipy.stats</code> package provides statistical functions, the
<code>pandas</code> package is used to work with data frames, and the
<code>numpy</code> package provides mathematical functions. In order to
save the plots generated, the code sets up a folder path using the OS
package. A data analysis is then performed by the code. The data to be
analyzed has already been loaded into a pandas data frame. Specifically,
paired samples will be analyzed using the t-test, and independent
samples will be analyzed using the t-test. In order to visualize the
results of the analysis, plots can be generated after the analysis has
been completed. This is accomplished with the matplotlib.pyplot package.
Different types of plots can be created with the plt object, such as
line plots, scatter plots, and bar plots. Plotting data is accepted as
an argument by these methods. As a final step, the code saves the plots
in a specified folder path using the OS package. For further analysis or
reporting, the plots can be easily accessed.</p>
</div>
<div class="cell code" data-execution_count="3">
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Imports from FinanceOps.</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> data_keys <span class="im">import</span> <span class="op">*</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> data <span class="im">import</span> load_index_data, load_stock_data</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> returns <span class="im">import</span> reinvestment_growth, prepare_ann_returns, prepare_mean_ann_returns</span></code></pre></div>
</div>
<div id="e6508b6b" class="cell markdown">
<p>Various functions and datasets are imported from modules
"FinanceOps", "data_keys", "data", and "returns". Financial operations
and financial data are contained in these modules. This code calls
specific functions from these modules after importing the necessary
functions and datasets. In order to load index data, the function
"load_index_data" is called. To load stock data, the function
"load_stock_data" is called. Most likely, these functions retrieve data
from a database or other designated source. Afterwards, the code calls
the "returns" module's function "reinvestment_growth". Taking
reinvestment of returns into account, this function calculates the
growth of an investment. Reinvestment growth may be calculated using a
formula or algorithm. Afterwards, the code invokes the functions
"prepare_ann_returns" and "prepare_mean_ann_returns" from the "returns"
module. It is likely that these functions prepare and format annual
returns and mean annual returns for further analysis or display. The
code imports functions and data related to finance operations, and then
uses them to retrieve and manipulate financial data. Functions and
datasets imported from different modules determine the specific
operations performed.</p>
</div>
<div class="cell markdown">
<p>The financial data we will be using has now been loaded.</p>
</div>
<div class="cell code" data-execution_count="4">
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the ticker-names for the stock-indices we consider.</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>ticker_SP500 <span class="op">=</span> <span class="st">&quot;S&amp;P 500&quot;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>ticker_SP400 <span class="op">=</span> <span class="st">&quot;S&amp;P 400&quot;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>ticker_SP600 <span class="op">=</span> <span class="st">&quot;S&amp;P 600&quot;</span></span></code></pre></div>
</div>
<div id="8856216e" class="cell markdown">
<p>Three variables are defined in this code: ticker_SP500, ticker_SP400,
and ticker_SP600. The variables represent the ticker names of different
stock indices. "S&amp;P 500", "S&amp;P 400", and "S&amp;P 600" are the
ticker names. Later in the code, these ticker names can be used to
reference specific stock indices.</p>
</div>
<div class="cell code" data-execution_count="5">
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the financial data for the stock-indices.</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>df_SP500 <span class="op">=</span> load_index_data(ticker<span class="op">=</span>ticker_SP500)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>df_SP400 <span class="op">=</span> load_index_data(ticker<span class="op">=</span>ticker_SP400, book_value<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>df_SP600 <span class="op">=</span> load_index_data(ticker<span class="op">=</span>ticker_SP600, book_value<span class="op">=</span><span class="va">False</span>)</span></code></pre></div>
</div>
<div id="4aedbad0" class="cell markdown">
<p>Three different stock indices are loaded in this code: the S&amp;P
500, the S&amp;P 400, and the S&amp;P 600. Each index's data is stored
in a separate data frame, df_SP500, df_SP400, and df_SP600. Each index's
ticker symbol is passed to the load_index_data function. This function
is called with the ticker symbol stored in the variable ticker_SP500 for
the S&amp;P 500. With respect to the S&amp;P 400 and S&amp;P 600, the
function is called with the ticker symbols stored in the variables
ticker_SP400 and ticker_SP600. The book_value parameter for the S&amp;P
400 and S&amp;P 600 is set to False, indicating that the data being
loaded for these indices does not include book value information.</p>
</div>
<div class="cell markdown">
<p>In particular, I was unable to access the original fundamental data
for the NASDAQ index. I also retrieved data for the Exchange Traded Fund
(ETF) with the ticker symbol QQQ, which mirrors the performance of the
NASDAQ index. Morningstar Direct provided this data. Rather than Sales
Per Share data, the database only provided P/Sales data. To overcome
this limitation, I estimated the Sales Per Share using the following
formula: Divide the Share Price at time-step "t" by the corresponding
P/Sales ratio at time-step "t".</p>
</div>
<div class="cell code" data-execution_count="6">
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load NASDAQ data for the ETF with ticker QQQ.</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>ticker_QQQ <span class="op">=</span> <span class="st">&quot;QQQ&quot;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>df_QQQ <span class="op">=</span> load_stock_data(ticker<span class="op">=</span>ticker_QQQ, earnings<span class="op">=</span><span class="va">False</span>, book_value<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Estimate Dividend Yield from diff. btw. Total Return and Share-Price.</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>df_QQQ[DIVIDEND_YIELD] <span class="op">=</span> reinvestment_growth(df_QQQ, smooth<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
</div>
<div id="cf88d92e" class="cell markdown">
<p>The code below loads NASDAQ data for an ETF (Exchange-Traded Fund)
with the ticker symbol QQQ. The code assigns the ticker symbol "QQQ" to
the variable ticker_QQQ. Next, it calls load_stock_data with the
argument ticker set to ticker_QQQ, and earnings and book_value set to
false. The function loads stock data from the NASDAQ dataset for the
specified ticker and returns it as a DataFrame. DataFrame df_QQQ is then
assigned to the returned DataFrame. To estimate the dividend yield for
each entry in the df_QQQ DataFrame, the code uses the
reinvestment_growth function. Dividend yield is calculated by
subtracting total return from share price. Dividend yield values are
added to the df_QQQ DataFrame as a column named DIVIDEND_YIELD. If
smooth is set to True in the reinvestment_growth function, then the
dividend yield data might be further processed or smoothed.</p>
</div>
<div class="cell markdown">
<p>Let's explain the formulas and concepts in plain English: Total
Return is the product of shares, which can increase due to dividend
reinvestment (ignoring taxes), and share price. As the inverse of the
investment period in years, the annualized return between the starting
date "t" and the end date "t+Years" is calculated as the ratio of the
Total Return at the starting date to the Total Return at the end date.
The annualized return is obtained by subtracting 1 from this result.
Given the P/Sales ratio at time step "t," we have derived two formulas
to estimate the mean and standard deviation of the annualized
return.</p>
<p>The estimated mean annualized return is obtained by dividing a
parameter called "a" by the P/Sales ratio raised to the power of the
inverse of the investment period in years. This result is subtracted by
1. Divide the P/Sales ratio raised to the power of the inverse of the
investment period in years by the estimated standard deviation of the
annualized return. There are three factors that can be used to estimate
the parameters "a" and "b": (1) dividend reinvestment growth, (2) growth
in Sales Per Share, and (3) changes in P/S valuation ratios. For "a,"
multiply the expected dividend yield plus 1, the expected sales per
share growth plus 1, and the expected P/S ratio raised to the power of
the inverse of the investment period in years. "B" is estimated by
calculating the standard deviation of the expression: dividend yield
plus 1 multiplied by sales per share growth plus 1 multiplied by the
P/Sales ratio raised to the power of the inverse of the investment
period. Dividend yield, sales growth, and P/S ratios can be forecasted
in order to predict future stock returns. For these factors, historical
values can be used, or alternative values can be used if the future
looks different.</p>
</div>
<div class="cell markdown">
<p>The forecasting model is implemented in this class.</p>
</div>
<div class="cell code" data-execution_count="7">
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ForecastModel:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Mathematical model used to forecast long-term stock returns.</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, dividend_yield, sales_growth,</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>                 psales, years):</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">        Create a new model and fit it with the given data.</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">        :param dividend_yield: Array with dividend yields.</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co">        :param sales_growth: Array with one-year sales growth.</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="co">        :param psales: Array with P/Sales ratios.</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="co">        :param years: Number of years.</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Copy args to self.</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Note the +1 for dividend yield and sales-growth</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># so we don&#39;t have to do it several times below.</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.dividend_yield <span class="op">=</span> np.array(dividend_yield) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.sales_growth <span class="op">=</span> np.array(sales_growth) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.psales <span class="op">=</span> psales</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.years <span class="op">=</span> years</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate the `a` parameter for the mean ann.return.</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.a <span class="op">=</span> <span class="va">self</span>.mean_parameter()</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate the `b` parameter for the std.dev. ann.return.</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.b <span class="op">=</span> <span class="va">self</span>.std_parameter()</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forecast(<span class="va">self</span>, psales_t):</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a><span class="co">        Use the fitted model to forecast the mean and std.dev.</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a><span class="co">        for the future stock returns.</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a><span class="co">        :param psales_t: Array with different P/Sales ratios at buy-time.</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a><span class="co">        :return: Two arrays with mean and std.ann. for the ann. returns</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a><span class="co">                 for each of the psales_t values.</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Annualized psales_t which is used in both formulas.</span></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>        psales_t_ann <span class="op">=</span> psales_t <span class="op">**</span> (<span class="dv">1</span><span class="op">/</span><span class="va">self</span>.years)</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Forecast the mean and std.dev. for the ann. returns</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>        <span class="co"># for the different choices of P/Sales ratios at the</span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>        <span class="co"># time of buying the stock.</span></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>        mean <span class="op">=</span> <span class="va">self</span>.a <span class="op">/</span> psales_t_ann <span class="op">-</span> <span class="fl">1.0</span></span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>        std <span class="op">=</span> <span class="va">self</span>.b <span class="op">/</span> psales_t_ann</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> mean, std</span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> mean_parameter(<span class="va">self</span>):</span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a><span class="co">        Estimate the parameter `a` used in the formula for the</span></span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a><span class="co">        mean annualized return, given arrays with distributions</span></span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a><span class="co">        for the dividend yield, sales-growth and P/Sales.</span></span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a><span class="co">        :return: The parameter `a` for the mean return formula.</span></span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>        <span class="co"># We assume dividend_yield and sales_growth is already +1.</span></span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> np.mean(<span class="va">self</span>.dividend_yield) <span class="op">\</span></span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a>          <span class="op">*</span> np.mean(<span class="va">self</span>.sales_growth) <span class="op">\</span></span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a>          <span class="op">*</span> np.mean(<span class="va">self</span>.psales <span class="op">**</span> (<span class="dv">1</span><span class="op">/</span><span class="va">self</span>.years))</span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a</span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> std_parameter(<span class="va">self</span>, num_samples<span class="op">=</span><span class="dv">10000</span>):</span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a><span class="co">        Estimate the parameter `b` used in the formula for the</span></span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true" tabindex="-1"></a><span class="co">        std.dev. annualized return, given arrays with distributions</span></span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true" tabindex="-1"></a><span class="co">        for the dividend yield, sales-growth and P/Sales.</span></span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-74"><a href="#cb7-74" aria-hidden="true" tabindex="-1"></a><span class="co">        This is estimated using Monte Carlo simulation / resampling</span></span>
<span id="cb7-75"><a href="#cb7-75" aria-hidden="true" tabindex="-1"></a><span class="co">        of the given data, which is assumed to be independent of</span></span>
<span id="cb7-76"><a href="#cb7-76" aria-hidden="true" tabindex="-1"></a><span class="co">        each other and over time.</span></span>
<span id="cb7-77"><a href="#cb7-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-78"><a href="#cb7-78" aria-hidden="true" tabindex="-1"></a><span class="co">        :param num_samples: Number of Monte Carlo samples.</span></span>
<span id="cb7-79"><a href="#cb7-79" aria-hidden="true" tabindex="-1"></a><span class="co">        :return: The parameter `b` for the std.dev. return formula.</span></span>
<span id="cb7-80"><a href="#cb7-80" aria-hidden="true" tabindex="-1"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb7-81"><a href="#cb7-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-82"><a href="#cb7-82" aria-hidden="true" tabindex="-1"></a>        <span class="co"># We will do a Monte Carlo simulation / resampling</span></span>
<span id="cb7-83"><a href="#cb7-83" aria-hidden="true" tabindex="-1"></a>        <span class="co"># from the supplied arrays of data. For each year</span></span>
<span id="cb7-84"><a href="#cb7-84" aria-hidden="true" tabindex="-1"></a>        <span class="co"># we take e.g. 10k random samples and then we</span></span>
<span id="cb7-85"><a href="#cb7-85" aria-hidden="true" tabindex="-1"></a>        <span class="co"># calculate the annualized growth-rates. This gives</span></span>
<span id="cb7-86"><a href="#cb7-86" aria-hidden="true" tabindex="-1"></a>        <span class="co"># us different values for dividend yields and sales-growth</span></span>
<span id="cb7-87"><a href="#cb7-87" aria-hidden="true" tabindex="-1"></a>        <span class="co"># for each year, instead of just taking one random</span></span>
<span id="cb7-88"><a href="#cb7-88" aria-hidden="true" tabindex="-1"></a>        <span class="co"># number and using that for all the years.</span></span>
<span id="cb7-89"><a href="#cb7-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-90"><a href="#cb7-90" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Shape of arrays to sample.</span></span>
<span id="cb7-91"><a href="#cb7-91" aria-hidden="true" tabindex="-1"></a>        shape <span class="op">=</span> (num_samples, <span class="va">self</span>.years)</span>
<span id="cb7-92"><a href="#cb7-92" aria-hidden="true" tabindex="-1"></a>        num_samples_total <span class="op">=</span> np.prod(shape)</span>
<span id="cb7-93"><a href="#cb7-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-94"><a href="#cb7-94" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sample the dividend yield. We assume it is already +1.</span></span>
<span id="cb7-95"><a href="#cb7-95" aria-hidden="true" tabindex="-1"></a>        dividend_yield_sample <span class="op">=</span> np.random.choice(<span class="va">self</span>.dividend_yield, size<span class="op">=</span>shape)</span>
<span id="cb7-96"><a href="#cb7-96" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compound the growth through the years.</span></span>
<span id="cb7-97"><a href="#cb7-97" aria-hidden="true" tabindex="-1"></a>        dividend_yield_sample <span class="op">=</span> np.prod(dividend_yield_sample, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb7-98"><a href="#cb7-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-99"><a href="#cb7-99" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sample the sales-growth. We assume it is already +1.</span></span>
<span id="cb7-100"><a href="#cb7-100" aria-hidden="true" tabindex="-1"></a>        sales_growth_sample <span class="op">=</span> np.random.choice(<span class="va">self</span>.sales_growth, size<span class="op">=</span>shape)</span>
<span id="cb7-101"><a href="#cb7-101" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compound the growth through the years.</span></span>
<span id="cb7-102"><a href="#cb7-102" aria-hidden="true" tabindex="-1"></a>        sales_growth_sample <span class="op">=</span> np.prod(sales_growth_sample, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb7-103"><a href="#cb7-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-104"><a href="#cb7-104" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sample the P/Sales ratio at the time of selling.</span></span>
<span id="cb7-105"><a href="#cb7-105" aria-hidden="true" tabindex="-1"></a>        psales_sample <span class="op">=</span> np.random.choice(<span class="va">self</span>.psales, size<span class="op">=</span>num_samples)</span>
<span id="cb7-106"><a href="#cb7-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-107"><a href="#cb7-107" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Combine the three samples.</span></span>
<span id="cb7-108"><a href="#cb7-108" aria-hidden="true" tabindex="-1"></a>        combined_sample <span class="op">=</span> dividend_yield_sample <span class="op">*</span> sales_growth_sample <span class="op">*</span> psales_sample</span>
<span id="cb7-109"><a href="#cb7-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-110"><a href="#cb7-110" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate the `b` parameter.</span></span>
<span id="cb7-111"><a href="#cb7-111" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> np.std(combined_sample <span class="op">**</span> (<span class="dv">1</span><span class="op">/</span><span class="va">self</span>.years))</span>
<span id="cb7-112"><a href="#cb7-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-113"><a href="#cb7-113" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> b</span>
<span id="cb7-114"><a href="#cb7-114" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-115"><a href="#cb7-115" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _ttest(<span class="va">self</span>, err_forecast, err_baseline):</span>
<span id="cb7-116"><a href="#cb7-116" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb7-117"><a href="#cb7-117" aria-hidden="true" tabindex="-1"></a><span class="co">        Perform a t-test on the residual errors of the</span></span>
<span id="cb7-118"><a href="#cb7-118" aria-hidden="true" tabindex="-1"></a><span class="co">        forecasting model and the baseline to assess whether</span></span>
<span id="cb7-119"><a href="#cb7-119" aria-hidden="true" tabindex="-1"></a><span class="co">        their means are equal.</span></span>
<span id="cb7-120"><a href="#cb7-120" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb7-121"><a href="#cb7-121" aria-hidden="true" tabindex="-1"></a><span class="co">        When the resulting p_value is close to zero, the means</span></span>
<span id="cb7-122"><a href="#cb7-122" aria-hidden="true" tabindex="-1"></a><span class="co">        are unlikely to be equal.</span></span>
<span id="cb7-123"><a href="#cb7-123" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb7-124"><a href="#cb7-124" aria-hidden="true" tabindex="-1"></a><span class="co">        :param err_forecast:</span></span>
<span id="cb7-125"><a href="#cb7-125" aria-hidden="true" tabindex="-1"></a><span class="co">            Residual errors for the forecasting model.</span></span>
<span id="cb7-126"><a href="#cb7-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-127"><a href="#cb7-127" aria-hidden="true" tabindex="-1"></a><span class="co">        :param err_baseline:</span></span>
<span id="cb7-128"><a href="#cb7-128" aria-hidden="true" tabindex="-1"></a><span class="co">            Residual errors for the baseline.</span></span>
<span id="cb7-129"><a href="#cb7-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-130"><a href="#cb7-130" aria-hidden="true" tabindex="-1"></a><span class="co">        :return:</span></span>
<span id="cb7-131"><a href="#cb7-131" aria-hidden="true" tabindex="-1"></a><span class="co">            p_value</span></span>
<span id="cb7-132"><a href="#cb7-132" aria-hidden="true" tabindex="-1"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb7-133"><a href="#cb7-133" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-134"><a href="#cb7-134" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">True</span>:</span>
<span id="cb7-135"><a href="#cb7-135" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Paired t-test.</span></span>
<span id="cb7-136"><a href="#cb7-136" aria-hidden="true" tabindex="-1"></a>            t_value, p_value <span class="op">=</span> ttest_rel(a<span class="op">=</span>err_forecast, b<span class="op">=</span>err_baseline)</span>
<span id="cb7-137"><a href="#cb7-137" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb7-138"><a href="#cb7-138" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Un-paired / independent t-test.</span></span>
<span id="cb7-139"><a href="#cb7-139" aria-hidden="true" tabindex="-1"></a>            t_value, p_value <span class="op">=</span> ttest_ind(a<span class="op">=</span>err_forecast, b<span class="op">=</span>err_baseline, equal_var<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb7-140"><a href="#cb7-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-141"><a href="#cb7-141" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> p_value</span>
<span id="cb7-142"><a href="#cb7-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-143"><a href="#cb7-143" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> MAE(<span class="va">self</span>, psales_t, ann_rets):</span>
<span id="cb7-144"><a href="#cb7-144" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb7-145"><a href="#cb7-145" aria-hidden="true" tabindex="-1"></a><span class="co">        Calculates the Mean Absolute Error (MAE) between the</span></span>
<span id="cb7-146"><a href="#cb7-146" aria-hidden="true" tabindex="-1"></a><span class="co">        model&#39;s forecasted mean and the observed annualized returns.</span></span>
<span id="cb7-147"><a href="#cb7-147" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb7-148"><a href="#cb7-148" aria-hidden="true" tabindex="-1"></a><span class="co">        Also calculates the MAE between the baseline and the</span></span>
<span id="cb7-149"><a href="#cb7-149" aria-hidden="true" tabindex="-1"></a><span class="co">        observed annualized returns.</span></span>
<span id="cb7-150"><a href="#cb7-150" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb7-151"><a href="#cb7-151" aria-hidden="true" tabindex="-1"></a><span class="co">        Also calculates the p-value that the forecasted and</span></span>
<span id="cb7-152"><a href="#cb7-152" aria-hidden="true" tabindex="-1"></a><span class="co">        baseline MAE values are equal.</span></span>
<span id="cb7-153"><a href="#cb7-153" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb7-154"><a href="#cb7-154" aria-hidden="true" tabindex="-1"></a><span class="co">        :param psales_t:</span></span>
<span id="cb7-155"><a href="#cb7-155" aria-hidden="true" tabindex="-1"></a><span class="co">            Array with different P/Sales ratios at buy-time.</span></span>
<span id="cb7-156"><a href="#cb7-156" aria-hidden="true" tabindex="-1"></a><span class="co">            </span></span>
<span id="cb7-157"><a href="#cb7-157" aria-hidden="true" tabindex="-1"></a><span class="co">        :param ann_rets:</span></span>
<span id="cb7-158"><a href="#cb7-158" aria-hidden="true" tabindex="-1"></a><span class="co">            Array with the corresponding annualized returns.</span></span>
<span id="cb7-159"><a href="#cb7-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-160"><a href="#cb7-160" aria-hidden="true" tabindex="-1"></a><span class="co">        :return:</span></span>
<span id="cb7-161"><a href="#cb7-161" aria-hidden="true" tabindex="-1"></a><span class="co">            mae_forecast: MAE between model&#39;s forecast and actual returns.</span></span>
<span id="cb7-162"><a href="#cb7-162" aria-hidden="true" tabindex="-1"></a><span class="co">            mae_baseline: MAE between baseline and actual returns.</span></span>
<span id="cb7-163"><a href="#cb7-163" aria-hidden="true" tabindex="-1"></a><span class="co">            p_value: p-value whether the two MAE values are equal.</span></span>
<span id="cb7-164"><a href="#cb7-164" aria-hidden="true" tabindex="-1"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb7-165"><a href="#cb7-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-166"><a href="#cb7-166" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Forecast the mean and std.dev. for the stock returns,</span></span>
<span id="cb7-167"><a href="#cb7-167" aria-hidden="true" tabindex="-1"></a>        <span class="co"># from the historical P/Sales ratios.</span></span>
<span id="cb7-168"><a href="#cb7-168" aria-hidden="true" tabindex="-1"></a>        mean_forecast, std_forecast <span class="op">=</span> <span class="va">self</span>.forecast(psales_t<span class="op">=</span>psales_t)</span>
<span id="cb7-169"><a href="#cb7-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-170"><a href="#cb7-170" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Errors between observed data and forecasting model.</span></span>
<span id="cb7-171"><a href="#cb7-171" aria-hidden="true" tabindex="-1"></a>        err_forecast <span class="op">=</span> np.<span class="bu">abs</span>(ann_rets <span class="op">-</span> mean_forecast)</span>
<span id="cb7-172"><a href="#cb7-172" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-173"><a href="#cb7-173" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Baseline errors between observed data and its mean.</span></span>
<span id="cb7-174"><a href="#cb7-174" aria-hidden="true" tabindex="-1"></a>        err_baseline <span class="op">=</span> np.<span class="bu">abs</span>(ann_rets <span class="op">-</span> np.mean(ann_rets))</span>
<span id="cb7-175"><a href="#cb7-175" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-176"><a href="#cb7-176" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Mean Absolute Errors (MAE).</span></span>
<span id="cb7-177"><a href="#cb7-177" aria-hidden="true" tabindex="-1"></a>        mae_forecast <span class="op">=</span> np.mean(err_forecast)</span>
<span id="cb7-178"><a href="#cb7-178" aria-hidden="true" tabindex="-1"></a>        mae_baseline <span class="op">=</span> np.mean(err_baseline)</span>
<span id="cb7-179"><a href="#cb7-179" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-180"><a href="#cb7-180" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Hypothesis test whether the two MAE values are equal.</span></span>
<span id="cb7-181"><a href="#cb7-181" aria-hidden="true" tabindex="-1"></a>        p_value <span class="op">=</span> <span class="va">self</span>._ttest(err_forecast<span class="op">=</span>err_forecast,</span>
<span id="cb7-182"><a href="#cb7-182" aria-hidden="true" tabindex="-1"></a>                              err_baseline<span class="op">=</span>err_baseline)</span>
<span id="cb7-183"><a href="#cb7-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-184"><a href="#cb7-184" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> mae_forecast, mae_baseline, p_value</span>
<span id="cb7-185"><a href="#cb7-185" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-186"><a href="#cb7-186" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> R_squared(<span class="va">self</span>, psales_t, ann_rets):</span>
<span id="cb7-187"><a href="#cb7-187" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb7-188"><a href="#cb7-188" aria-hidden="true" tabindex="-1"></a><span class="co">        Calculate the Coefficient of Determination R^2 for</span></span>
<span id="cb7-189"><a href="#cb7-189" aria-hidden="true" tabindex="-1"></a><span class="co">        measuring the Goodness of Fit between the forecasted</span></span>
<span id="cb7-190"><a href="#cb7-190" aria-hidden="true" tabindex="-1"></a><span class="co">        mean and the observed annualized returns.</span></span>
<span id="cb7-191"><a href="#cb7-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-192"><a href="#cb7-192" aria-hidden="true" tabindex="-1"></a><span class="co">        An R^2 value of one means there is a perfect fit and</span></span>
<span id="cb7-193"><a href="#cb7-193" aria-hidden="true" tabindex="-1"></a><span class="co">        the forecasting model explains all of the variance</span></span>
<span id="cb7-194"><a href="#cb7-194" aria-hidden="true" tabindex="-1"></a><span class="co">        in the data. An R^2 value of zero means the forecasting</span></span>
<span id="cb7-195"><a href="#cb7-195" aria-hidden="true" tabindex="-1"></a><span class="co">        model does not explain any of the variance in the data.</span></span>
<span id="cb7-196"><a href="#cb7-196" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb7-197"><a href="#cb7-197" aria-hidden="true" tabindex="-1"></a><span class="co">        Note that because the forecasting model is non-linear,</span></span>
<span id="cb7-198"><a href="#cb7-198" aria-hidden="true" tabindex="-1"></a><span class="co">        the R^2 can become negative if the model fits poorly</span></span>
<span id="cb7-199"><a href="#cb7-199" aria-hidden="true" tabindex="-1"></a><span class="co">        on data with a large variance.</span></span>
<span id="cb7-200"><a href="#cb7-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-201"><a href="#cb7-201" aria-hidden="true" tabindex="-1"></a><span class="co">        :param psales_t:</span></span>
<span id="cb7-202"><a href="#cb7-202" aria-hidden="true" tabindex="-1"></a><span class="co">            Array with different P/Sales ratios at buy-time.</span></span>
<span id="cb7-203"><a href="#cb7-203" aria-hidden="true" tabindex="-1"></a><span class="co">            </span></span>
<span id="cb7-204"><a href="#cb7-204" aria-hidden="true" tabindex="-1"></a><span class="co">        :param ann_rets:</span></span>
<span id="cb7-205"><a href="#cb7-205" aria-hidden="true" tabindex="-1"></a><span class="co">            Array with the corresponding annualized returns.</span></span>
<span id="cb7-206"><a href="#cb7-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-207"><a href="#cb7-207" aria-hidden="true" tabindex="-1"></a><span class="co">        :return:</span></span>
<span id="cb7-208"><a href="#cb7-208" aria-hidden="true" tabindex="-1"></a><span class="co">            R^2 value.</span></span>
<span id="cb7-209"><a href="#cb7-209" aria-hidden="true" tabindex="-1"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb7-210"><a href="#cb7-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-211"><a href="#cb7-211" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Forecast the mean and std.dev. for the stock returns,</span></span>
<span id="cb7-212"><a href="#cb7-212" aria-hidden="true" tabindex="-1"></a>        <span class="co"># from the historical P/Sales ratios.</span></span>
<span id="cb7-213"><a href="#cb7-213" aria-hidden="true" tabindex="-1"></a>        mean_forecast, std_forecast <span class="op">=</span> <span class="va">self</span>.forecast(psales_t<span class="op">=</span>psales_t)</span>
<span id="cb7-214"><a href="#cb7-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-215"><a href="#cb7-215" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Errors between observed data and forecasting model.</span></span>
<span id="cb7-216"><a href="#cb7-216" aria-hidden="true" tabindex="-1"></a>        err_forecast <span class="op">=</span> (ann_rets <span class="op">-</span> mean_forecast) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb7-217"><a href="#cb7-217" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-218"><a href="#cb7-218" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Baseline errors between observed data and its mean.</span></span>
<span id="cb7-219"><a href="#cb7-219" aria-hidden="true" tabindex="-1"></a>        err_baseline <span class="op">=</span> (ann_rets <span class="op">-</span> np.mean(ann_rets)) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb7-220"><a href="#cb7-220" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-221"><a href="#cb7-221" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sum of Squared Errors (SSE) for the forecasting model.</span></span>
<span id="cb7-222"><a href="#cb7-222" aria-hidden="true" tabindex="-1"></a>        sse <span class="op">=</span> np.<span class="bu">sum</span>(err_forecast)</span>
<span id="cb7-223"><a href="#cb7-223" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-224"><a href="#cb7-224" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sum of Squared Errors (SST) for the baseline.</span></span>
<span id="cb7-225"><a href="#cb7-225" aria-hidden="true" tabindex="-1"></a>        sst <span class="op">=</span> np.<span class="bu">sum</span>(err_baseline)</span>
<span id="cb7-226"><a href="#cb7-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-227"><a href="#cb7-227" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The R^2 value.</span></span>
<span id="cb7-228"><a href="#cb7-228" aria-hidden="true" tabindex="-1"></a>        R_squared <span class="op">=</span> <span class="fl">1.0</span> <span class="op">-</span> sse <span class="op">/</span> sst</span>
<span id="cb7-229"><a href="#cb7-229" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-230"><a href="#cb7-230" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> R_squared</span></code></pre></div>
</div>
<div id="6dd21e0a" class="cell markdown">
<p>Based on various parameters, this code defines a class called
"ForecastModel" to forecast long-term stock returns. Models are
initialized with given data using the <strong>init</strong> method.
Dividend yields, sales growth, P/S ratios, and the number of years are
inputs. In turn, these parameters are stored as attributes of the
<code>ForecastModel</code> object. When the stock is bought, the
forecast method predicts the mean and standard deviation of annualized
returns for different P/Sales ratios. Calculates annualized P/S ratios
based on an array of P/S ratios. Forecasting the mean and standard
deviation is then done using these ratios as well as the a and b
parameters calculated in the <strong>init</strong> method. A mean
parameter is estimated using the "mean_parameter" method. Dividend
yields, sales growth, and P/Sales ratios are inputs, and it calculates
the mean of each. Then the P/Sales ratios are raised to the power of
1/years to calculate the <code>a</code> parameter. The
<code>std_parameter</code> method is used to estimate the parameter
<code>b</code> in the formula for standard deviation. A Monte Carlo
simulation is used to resample the data and calculate the standard
deviation. It takes an optional parameter <code>num_samples</code> to
specify the number of Monte Carlo samples to use. Using dividend yields,
sales growth, and P/Sales ratios, it calculates the <code>b</code>
parameter. A t-test is performed on the residual errors of the
forecasting model and a baseline to see if their means are similar. It
uses the <code>ttest_rel</code> function from the
<code>scipy.stats</code> module to calculate the t-value and p-value. In
this method, we calculate the Mean Absolute Error (MAE) between the
model's forecasted mean and the observed annualized return. In addition,
it calculates the MAE between a baseline and observed returns, as well
as the p-value for whether the two MAE values are equal. Using the
forecast method, it forecasts the mean and standard deviation of
returns, and then calculates the errors between the observations and the
forecasts. R_squared calculates the Coefficient of Determination (R^2)
for measuring the Goodness of Fit between the forecasted mean and the
observed annualized returns. For the forecasting model and the baseline,
the sum of squared errors (SSE) is calculated using the same approach as
the MAE method. After calculating these values, it calculates the R^2
value.</p>
</div>
<div class="cell markdown">
<p>A forecasting model's statistics are printed by this
helper-function.</p>
</div>
<div class="cell code" data-execution_count="8">
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> print_statistics(model, psales_t, ann_rets):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculate and print the Goodness of Fit statistics</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">    for a model&#39;s forecast compared to the baseline.</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">    The p-value results from a paired t-test whether</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">    the values are equal. A p-value close to zero means</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">    that the values are unlikely to be equal.</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co">    :param model:</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co">        Instance of the ForecastModel class.</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co">    :param psales_t:</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co">        Array with different P/Sales ratios at buy-time.</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="co">    :param ann_rets:</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="co">        Array with the corresponding annualized returns.</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Print header.</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\t</span><span class="st">Forecast</span><span class="ch">\t</span><span class="st">Baseline</span><span class="ch">\t</span><span class="st">p-value&quot;</span>)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;=================================================&quot;</span>)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Mean Absolute Error (MAE).</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    mae_forecast, mae_baseline, p_value <span class="op">=</span> model.MAE(psales_t<span class="op">=</span>psales_t,</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>                                                    ann_rets<span class="op">=</span>ann_rets)</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    msg <span class="op">=</span> <span class="st">&quot;MAE:</span><span class="ch">\t</span><span class="sc">{0:.1%}</span><span class="ch">\t\t</span><span class="sc">{1:.1%}</span><span class="ch">\t\t</span><span class="sc">{2:.2e}</span><span class="st">&quot;</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    msg <span class="op">=</span> msg.<span class="bu">format</span>(mae_forecast, mae_baseline, p_value)</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(msg)</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># R^2.</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    R_squared <span class="op">=</span> model.R_squared(psales_t<span class="op">=</span>psales_t,</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>                                ann_rets<span class="op">=</span>ann_rets)</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>    msg <span class="op">=</span> <span class="st">&quot;R^2:</span><span class="ch">\t</span><span class="sc">{0:.2f}</span><span class="st">&quot;</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>    msg <span class="op">=</span> msg.<span class="bu">format</span>(R_squared)</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(msg)</span></code></pre></div>
</div>
<div id="9d2a18d6" class="cell markdown">
<p>A function called "print_statistics" calculates and prints Goodness
of Fit statistics for a forecast model compared to a baseline. There are
three parameters: "model", which is an instance of the ForecastModel
class, "psales_t", which is an array of different P/Sales ratios at
purchase time, and "ann_rets", which is an array of annualized returns.
In the function, a header indicates the forecast, baseline, and p-value
columns. By using the model's MAE method, it calculates the Mean
Absolute Error (MAE) for both the forecast and the baseline.
"mae_forecast", "mae_baseline", and "p_value" contain MAE values and
p-values. Next, the code formats a message string with placeholders for
MAE values and p-values. For both forecasts and baselines, the formatted
message displays the MAE values and p-values. The code then calculates
the R^2 (R-squared) value using the model's R_squared method. This is
the value assigned to the variable "R_squared". Another message string
is formatted with a placeholder for the R^2 value, and this message is
then printed to display the R^2 value. To summarize, this code
calculates and prints the Goodness of Fit statistics for a forecast
model compared to a baseline.</p>
</div>
<div class="cell markdown">
<p>This function plots historical annualized returns and overlays them
with the forecasting model's mean and standard deviation.</p>
</div>
<div class="cell code" data-execution_count="9">
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_ann_returns(ticker, df, years, years_range<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>                     dividend_yield<span class="op">=</span><span class="va">None</span>, sales_growth<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                     psales<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>                     psales_min<span class="op">=</span><span class="va">None</span>, psales_max<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Create a plot with the actual historical returns showing</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">    the P/Sales ratios vs. future Annualized Returns. Overlay</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co">    this plot with the estimated mean and std.dev. from the</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co">    mathematical forecasting model we have derived above.</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="co">    The optional params are taken from the DataFrame `df`</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="co">    if not supplied. This allows you to override some or</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="co">    all of the data used in the forecasting model e.g.</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="co">    to change assumptions about future sales-growth.</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="co">    :param ticker: String with ticker for the stock or index.</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="co">    :param df: Pandas DataFrame.</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="co">    :param years: Number of investment years.</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="co">    :param years_range:</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="co">        If &gt; 0 then plot the mean ann. returns between</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="co">        years - years_range and years + years_range.</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="co">    :param dividend_yield: (Optional) Array with dividend yields.</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="co">    :param sales_growth: (Optional) Array with one-year sales growth.</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="co">    :param psales: (Optional) Array with P/Sales ratios.</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a><span class="co">    :param psales_min: (Optional) Min P/Sales for plotting curves.</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="co">    :param psales_max: (Optional) Max P/Sales for plotting curves.</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a><span class="co">    :return: None.</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a single plot.</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>    fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">10</span>))</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> fig.add_subplot(<span class="dv">211</span>)</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Select only the data we need.</span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>    df2 <span class="op">=</span> df[[TOTAL_RETURN, DIVIDEND_YIELD, SALES_GROWTH, PSALES]]</span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Remove rows for which there is missing data.</span></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>    df2 <span class="op">=</span> df2.dropna()</span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Part of the title for the data&#39;s date-range.</span></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>    start_date, end_date <span class="op">=</span> df2.index[[<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>]]</span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>    title_dates <span class="op">=</span> <span class="st">&quot;(</span><span class="sc">{0}</span><span class="st">-</span><span class="sc">{1}</span><span class="st">)&quot;</span>.<span class="bu">format</span>(start_date.year, end_date.year)</span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get Dividend Yield if none provided.</span></span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> dividend_yield <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>        dividend_yield <span class="op">=</span> df2[DIVIDEND_YIELD]</span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get Sales Growth if none provided.</span></span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> sales_growth <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>        sales_growth <span class="op">=</span> df2[SALES_GROWTH]</span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get P/Sales if none provided.</span></span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> psales <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a>        psales <span class="op">=</span> df2[PSALES]</span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-56"><a href="#cb9-56" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get min P/Sales for plotting if none provided.</span></span>
<span id="cb9-57"><a href="#cb9-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> psales_min <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb9-58"><a href="#cb9-58" aria-hidden="true" tabindex="-1"></a>        psales_min <span class="op">=</span> np.<span class="bu">min</span>(psales)</span>
<span id="cb9-59"><a href="#cb9-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-60"><a href="#cb9-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get max P/Sales for plotting if none provided.</span></span>
<span id="cb9-61"><a href="#cb9-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> psales_max <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb9-62"><a href="#cb9-62" aria-hidden="true" tabindex="-1"></a>        psales_max <span class="op">=</span> np.<span class="bu">max</span>(psales)</span>
<span id="cb9-63"><a href="#cb9-63" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-64"><a href="#cb9-64" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create the forecasting model and fit it to the data.</span></span>
<span id="cb9-65"><a href="#cb9-65" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> ForecastModel(dividend_yield<span class="op">=</span>dividend_yield,</span>
<span id="cb9-66"><a href="#cb9-66" aria-hidden="true" tabindex="-1"></a>                          sales_growth<span class="op">=</span>sales_growth,</span>
<span id="cb9-67"><a href="#cb9-67" aria-hidden="true" tabindex="-1"></a>                          psales<span class="op">=</span>psales, years<span class="op">=</span>years)</span>
<span id="cb9-68"><a href="#cb9-68" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-69"><a href="#cb9-69" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Evenly spaced P/Sales ratios between historic min and max.</span></span>
<span id="cb9-70"><a href="#cb9-70" aria-hidden="true" tabindex="-1"></a>    psales_t <span class="op">=</span> np.linspace(start<span class="op">=</span>psales_min, stop<span class="op">=</span>psales_max, num<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb9-71"><a href="#cb9-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-72"><a href="#cb9-72" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Use the model to forecast the mean and std ann.returns.</span></span>
<span id="cb9-73"><a href="#cb9-73" aria-hidden="true" tabindex="-1"></a>    mean, std <span class="op">=</span> model.forecast(psales_t<span class="op">=</span>psales_t)</span>
<span id="cb9-74"><a href="#cb9-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-75"><a href="#cb9-75" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the mean ann.return.</span></span>
<span id="cb9-76"><a href="#cb9-76" aria-hidden="true" tabindex="-1"></a>    ax.plot(psales_t, mean, color<span class="op">=</span><span class="st">&quot;black&quot;</span>, label<span class="op">=</span><span class="st">&quot;Forecast Mean&quot;</span>)</span>
<span id="cb9-77"><a href="#cb9-77" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-78"><a href="#cb9-78" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot one standard deviation.</span></span>
<span id="cb9-79"><a href="#cb9-79" aria-hidden="true" tabindex="-1"></a>    color <span class="op">=</span> <span class="st">&quot;green&quot;</span></span>
<span id="cb9-80"><a href="#cb9-80" aria-hidden="true" tabindex="-1"></a>    alpha <span class="op">=</span> <span class="fl">0.3</span></span>
<span id="cb9-81"><a href="#cb9-81" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot lines below and above mean.</span></span>
<span id="cb9-82"><a href="#cb9-82" aria-hidden="true" tabindex="-1"></a>    ax.plot(psales_t, mean<span class="op">-</span>std, color<span class="op">=</span>color,</span>
<span id="cb9-83"><a href="#cb9-83" aria-hidden="true" tabindex="-1"></a>            label<span class="op">=</span><span class="st">&quot;Forecast Mean $\pm$ 1 Std.Dev.&quot;</span>)</span>
<span id="cb9-84"><a href="#cb9-84" aria-hidden="true" tabindex="-1"></a>    ax.plot(psales_t, mean<span class="op">+</span>std, color<span class="op">=</span>color)</span>
<span id="cb9-85"><a href="#cb9-85" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the areas.</span></span>
<span id="cb9-86"><a href="#cb9-86" aria-hidden="true" tabindex="-1"></a>    ax.fill_between(psales_t, mean<span class="op">+</span>std, mean<span class="op">-</span>std,</span>
<span id="cb9-87"><a href="#cb9-87" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span>color, edgecolor<span class="op">=</span>color, alpha<span class="op">=</span>alpha)</span>
<span id="cb9-88"><a href="#cb9-88" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-89"><a href="#cb9-89" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot two standard deviations.</span></span>
<span id="cb9-90"><a href="#cb9-90" aria-hidden="true" tabindex="-1"></a>    color <span class="op">=</span> <span class="st">&quot;red&quot;</span></span>
<span id="cb9-91"><a href="#cb9-91" aria-hidden="true" tabindex="-1"></a>    alpha <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb9-92"><a href="#cb9-92" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot lines below and above mean.</span></span>
<span id="cb9-93"><a href="#cb9-93" aria-hidden="true" tabindex="-1"></a>    ax.plot(psales_t, mean<span class="op">-</span><span class="dv">2</span><span class="op">*</span>std, color<span class="op">=</span>color,</span>
<span id="cb9-94"><a href="#cb9-94" aria-hidden="true" tabindex="-1"></a>            label<span class="op">=</span><span class="st">&quot;Forecast Mean $\pm$ 2 Std.Dev.&quot;</span>)</span>
<span id="cb9-95"><a href="#cb9-95" aria-hidden="true" tabindex="-1"></a>    ax.plot(psales_t, mean<span class="op">+</span><span class="dv">2</span><span class="op">*</span>std, color<span class="op">=</span>color) </span>
<span id="cb9-96"><a href="#cb9-96" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the areas.</span></span>
<span id="cb9-97"><a href="#cb9-97" aria-hidden="true" tabindex="-1"></a>    ax.fill_between(psales_t, mean<span class="op">-</span>std, mean<span class="op">-</span><span class="dv">2</span><span class="op">*</span>std,</span>
<span id="cb9-98"><a href="#cb9-98" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span>color, edgecolor<span class="op">=</span>color, alpha<span class="op">=</span>alpha)</span>
<span id="cb9-99"><a href="#cb9-99" aria-hidden="true" tabindex="-1"></a>    ax.fill_between(psales_t, mean<span class="op">+</span>std, mean<span class="op">+</span><span class="dv">2</span><span class="op">*</span>std,</span>
<span id="cb9-100"><a href="#cb9-100" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span>color, edgecolor<span class="op">=</span>color, alpha<span class="op">=</span>alpha)</span>
<span id="cb9-101"><a href="#cb9-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-102"><a href="#cb9-102" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get the actual ann. returns from the historic data.</span></span>
<span id="cb9-103"><a href="#cb9-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> years_range <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb9-104"><a href="#cb9-104" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Use the mean. ann. returns between [min_years, max_years].</span></span>
<span id="cb9-105"><a href="#cb9-105" aria-hidden="true" tabindex="-1"></a>        min_years <span class="op">=</span> years <span class="op">-</span> years_range</span>
<span id="cb9-106"><a href="#cb9-106" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> min_years <span class="op">&lt;</span> <span class="dv">1</span>:</span>
<span id="cb9-107"><a href="#cb9-107" aria-hidden="true" tabindex="-1"></a>            min_years <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb9-108"><a href="#cb9-108" aria-hidden="true" tabindex="-1"></a>        max_years <span class="op">=</span> years <span class="op">+</span> years_range</span>
<span id="cb9-109"><a href="#cb9-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-110"><a href="#cb9-110" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Get the mean ann.returns from the historic data.</span></span>
<span id="cb9-111"><a href="#cb9-111" aria-hidden="true" tabindex="-1"></a>        x, y <span class="op">=</span> prepare_mean_ann_returns(df<span class="op">=</span>df2,</span>
<span id="cb9-112"><a href="#cb9-112" aria-hidden="true" tabindex="-1"></a>                                        min_years<span class="op">=</span>min_years,</span>
<span id="cb9-113"><a href="#cb9-113" aria-hidden="true" tabindex="-1"></a>                                        max_years<span class="op">=</span>max_years,</span>
<span id="cb9-114"><a href="#cb9-114" aria-hidden="true" tabindex="-1"></a>                                        key<span class="op">=</span>PSALES)</span>
<span id="cb9-115"><a href="#cb9-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-116"><a href="#cb9-116" aria-hidden="true" tabindex="-1"></a>        <span class="co"># First part of the plot-title.</span></span>
<span id="cb9-117"><a href="#cb9-117" aria-hidden="true" tabindex="-1"></a>        title1 <span class="op">=</span> <span class="st">&quot;[</span><span class="sc">{0}</span><span class="st">] </span><span class="sc">{1}</span><span class="st">-</span><span class="sc">{2}</span><span class="st"> Year Mean Ann. Return </span><span class="sc">{3}</span><span class="st">&quot;</span>.<span class="bu">format</span>(ticker, min_years, max_years, title_dates)</span>
<span id="cb9-118"><a href="#cb9-118" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-119"><a href="#cb9-119" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Label for the scatter-plot of actual returns.</span></span>
<span id="cb9-120"><a href="#cb9-120" aria-hidden="true" tabindex="-1"></a>        label_returns <span class="op">=</span> <span class="st">&quot;Actual Returns (Mean)&quot;</span></span>
<span id="cb9-121"><a href="#cb9-121" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb9-122"><a href="#cb9-122" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Get the ann.returns from the historic data.</span></span>
<span id="cb9-123"><a href="#cb9-123" aria-hidden="true" tabindex="-1"></a>        x, y <span class="op">=</span> prepare_ann_returns(df<span class="op">=</span>df2, years<span class="op">=</span>years, key<span class="op">=</span>PSALES)</span>
<span id="cb9-124"><a href="#cb9-124" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-125"><a href="#cb9-125" aria-hidden="true" tabindex="-1"></a>        <span class="co"># First part of the plot-title.</span></span>
<span id="cb9-126"><a href="#cb9-126" aria-hidden="true" tabindex="-1"></a>        title1 <span class="op">=</span> <span class="st">&quot;[</span><span class="sc">{0}</span><span class="st">] </span><span class="sc">{1}</span><span class="st">-Year Ann. Return </span><span class="sc">{2}</span><span class="st">&quot;</span>.<span class="bu">format</span>(ticker, years, title_dates)</span>
<span id="cb9-127"><a href="#cb9-127" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-128"><a href="#cb9-128" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Label for the scatter-plot of actual returns.</span></span>
<span id="cb9-129"><a href="#cb9-129" aria-hidden="true" tabindex="-1"></a>        label_returns <span class="op">=</span> <span class="st">&quot;Actual Returns&quot;</span></span>
<span id="cb9-130"><a href="#cb9-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-131"><a href="#cb9-131" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Scatter-plot with the actual P/Sales vs. Ann.Returns.</span></span>
<span id="cb9-132"><a href="#cb9-132" aria-hidden="true" tabindex="-1"></a>    ax.scatter(x, y, label<span class="op">=</span>label_returns)</span>
<span id="cb9-133"><a href="#cb9-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-134"><a href="#cb9-134" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot baseline mean as horizontal dashed line.</span></span>
<span id="cb9-135"><a href="#cb9-135" aria-hidden="true" tabindex="-1"></a>    ax.axhline(y<span class="op">=</span>np.mean(y), color<span class="op">=</span><span class="st">&quot;black&quot;</span>, linestyle<span class="op">=</span><span class="st">&quot;--&quot;</span>,</span>
<span id="cb9-136"><a href="#cb9-136" aria-hidden="true" tabindex="-1"></a>               label<span class="op">=</span><span class="st">&quot;Baseline&quot;</span>)</span>
<span id="cb9-137"><a href="#cb9-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-138"><a href="#cb9-138" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Show the labels for what we have just plotted.</span></span>
<span id="cb9-139"><a href="#cb9-139" aria-hidden="true" tabindex="-1"></a>    ax.legend()</span>
<span id="cb9-140"><a href="#cb9-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-141"><a href="#cb9-141" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create plot-title.</span></span>
<span id="cb9-142"><a href="#cb9-142" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Second part of the title. Formula for mean ann. return.</span></span>
<span id="cb9-143"><a href="#cb9-143" aria-hidden="true" tabindex="-1"></a>    msg <span class="op">=</span> <span class="st">&quot;E[Ann Return] = </span><span class="sc">{0:.2f}</span><span class="st"> / (P/Sales ^ (1/</span><span class="sc">{1}</span><span class="st">)) - 1&quot;</span></span>
<span id="cb9-144"><a href="#cb9-144" aria-hidden="true" tabindex="-1"></a>    title2 <span class="op">=</span> msg.<span class="bu">format</span>(model.a, years)</span>
<span id="cb9-145"><a href="#cb9-145" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Third part of the title. Formula for std.dev. ann. return.</span></span>
<span id="cb9-146"><a href="#cb9-146" aria-hidden="true" tabindex="-1"></a>    msg <span class="op">=</span> <span class="st">&quot;Std[Ann Return] = </span><span class="sc">{0:.3f}</span><span class="st"> / (P/Sales ^ (1/</span><span class="sc">{1}</span><span class="st">))&quot;</span></span>
<span id="cb9-147"><a href="#cb9-147" aria-hidden="true" tabindex="-1"></a>    title3 <span class="op">=</span> msg.<span class="bu">format</span>(model.b, years)</span>
<span id="cb9-148"><a href="#cb9-148" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Combine and set the plot-title.</span></span>
<span id="cb9-149"><a href="#cb9-149" aria-hidden="true" tabindex="-1"></a>    title <span class="op">=</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>.join([title1, title2, title3])</span>
<span id="cb9-150"><a href="#cb9-150" aria-hidden="true" tabindex="-1"></a>    ax.set_title(title)</span>
<span id="cb9-151"><a href="#cb9-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-152"><a href="#cb9-152" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert y-ticks to percentages.</span></span>
<span id="cb9-153"><a href="#cb9-153" aria-hidden="true" tabindex="-1"></a>    formatter <span class="op">=</span> FuncFormatter(<span class="kw">lambda</span> y, _: <span class="st">&#39;</span><span class="sc">{:.0%}</span><span class="st">&#39;</span>.<span class="bu">format</span>(y))</span>
<span id="cb9-154"><a href="#cb9-154" aria-hidden="true" tabindex="-1"></a>    ax.yaxis.set_major_formatter(formatter)</span>
<span id="cb9-155"><a href="#cb9-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-156"><a href="#cb9-156" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set axes labels.</span></span>
<span id="cb9-157"><a href="#cb9-157" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">&quot;P/Sales&quot;</span>)</span>
<span id="cb9-158"><a href="#cb9-158" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="st">&quot;Annualized Return&quot;</span>)</span>
<span id="cb9-159"><a href="#cb9-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-160"><a href="#cb9-160" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Show grid.</span></span>
<span id="cb9-161"><a href="#cb9-161" aria-hidden="true" tabindex="-1"></a>    ax.grid()</span>
<span id="cb9-162"><a href="#cb9-162" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-163"><a href="#cb9-163" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Show the plot.</span></span>
<span id="cb9-164"><a href="#cb9-164" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb9-165"><a href="#cb9-165" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-166"><a href="#cb9-166" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Print the Goodness of Fit statistics.</span></span>
<span id="cb9-167"><a href="#cb9-167" aria-hidden="true" tabindex="-1"></a>    print_statistics(model<span class="op">=</span>model, psales_t<span class="op">=</span>x, ann_rets<span class="op">=</span>y)</span></code></pre></div>
</div>
<div id="4afc50f0" class="cell markdown">
<p>The code plots a stock's or index's actual historical returns.
P/Sales ratios are compared with future annualized returns. Overlaid on
the plot is an estimation of the mean and standard deviation derived
from a mathematical forecasting model. First, the code sets up the plot
and selects the data from a DataFrame. Rows with missing data are
removed. Following that, it checks if optional parameters such as
dividend yield, sales growth, and P/S ratios are provided, along with
their minimum and maximum values. It retrieves them from the DataFrame
if they are not present. After that, the code creates a forecasting
model and fits it to the data. P/Sales ratios are generated between the
historic minimum and maximum. Based on the P/S ratio, the forecasting
model forecasts the mean and standard deviation annualized returns. The
plot shows the mean annualized return and standard deviation, along with
two sets of lines below and above the mean. The code retrieves the mean
annualized returns from historic data within a specified range of years
if years_range is greater than zero. Along with the actual P/S ratio,
these are plotted as scatter points. In addition, the code plots a
horizontal dashed line to represent the baseline mean. In the code, the
plot title is set, the y-axis ticks are converted to percentages, the
axes are labeled, the grid is displayed, and the plot is displayed. The
code prints the Goodness of Fit statistics for the forecasting
model.</p>
</div>
<div class="cell markdown">
<p>To plot a comparison between Share-Price and Total Return, use this
helper function.</p>
</div>
<div class="cell code" data-execution_count="10">
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_price_total_return(df):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Plot Share-Price and Total Return normalized to start at 1.</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    df2 <span class="op">=</span> df[[TOTAL_RETURN, SHARE_PRICE]].dropna()</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    df2 <span class="op">/=</span> df2.values[<span class="dv">0</span>]</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    df2.plot(grid<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
</div>
<div id="c23f682c" class="cell markdown">
<p>The code defines a function called "plot_price_total_return", which
takes a dataframe as input. Using this function, you can plot the share
price and total return of a particular stock or investment, with both
values standardized to 1. From the input dataframe, the function creates
a new dataframe called "df2" by selecting only the columns related to
total return and share price. In the new dataframe, any rows with
missing values in these columns are removed. To normalize the values in
the "df2" dataframe, they are divided by the value of the first row. The
share price and total return values will start at 1 as a result. Lastly,
the function plots the normalized values from the "df2" dataframe, with
a grid displayed. Plotting the share price and total return over time,
with both values starting at 1 for easy comparison, will result in the
following plot.</p>
</div>
<div class="cell markdown">
<p>S&amp;P 500 is an index of 500 of the largest companies in the United
States. Due to its size, the S&amp;P 500 is a good gauge of the entire
U.S. stock market (see ).</p>
</div>
<div class="cell markdown">
<p>From 1989 to 2017, the following plot compares the share price of the
S&amp;P 500 with its Total Return. By reinvesting dividends back into
the S&amp;P 500 and ignoring taxes, the Total Return is calculated.</p>
</div>
<div class="cell code" data-execution_count="11">
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>plot_price_total_return(df<span class="op">=</span>df_SP500[<span class="st">&quot;1989&quot;</span>:])</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/dc2c9f74c1161e879e0a8f109ed2dee13f5687d6.png" /></p>
</div>
</div>
<div id="da72e9fb" class="cell markdown">
<p>Plot_price_total_return(df=df_SP500["1989":]) performs a specific
operation on a DataFrame df_SP500. A subset of the data is selected by
using the slice notation <code>["1989":]</code>. Until the end of the
DataFrame, this selects all rows starting with 1989. Afterward, it
performs a specific calculation or analysis on the selected subset.
Total return is the basis for this calculation. Based on the selected
subset of data, the code produces a plot or graph showing the total
return. In the code snippet, the plot or graph does not provide specific
details, but it can be inferred that it visualizes the total return over
time.</p>
</div>
<div class="cell markdown">
<p>Based on the above plots for S&amp;P 500 Share-Price and Total
Return, it is clearly only possible to determine whether a given value
was high or low in hindsight. To determine whether the S&amp;P 500 is
priced cheaply or expensively, we will use the P/Sales ratio. In the
next section, we will discuss how the P/Sales ratio has historically
been correlated with future returns and how it fits with the forecasting
model.</p>
<p>From 1989 to 2017, the P/Sales ratio varied roughly between 0.6 and
2.2, with a mean of 1.35.</p>
</div>
<div class="cell code" data-execution_count="12" data-scrolled="true">
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>df_SP500[PSALES].plot(grid<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<div class="output execute_result" data-execution_count="12">
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f8863226208&gt;</code></pre>
</div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/d75c4425993a31b78fec163af34c22ee5dc6d116.png" /></p>
</div>
</div>
<div id="da55042e" class="cell markdown">
<p>A DataFrame called "df_SP500" is plotted using this code. "PSALES" is
the column being plotted. First, access the DataFrame "df_SP500" and
extract the "PSALES" column. The data in this column probably pertains
to a specific product or group of products. After obtaining the specific
column, the code plots it. Data points from the "PSALES" column will be
displayed on the y-axis, while the index values of the DataFrame will
appear on the x-axis. In addition to the plot, there will also be a grid
to help visually organize the data points. For analysis or presentation
purposes, this code visualizes sales data from the "PSALES" column of
the "df_SP500" DataFrame.</p>
</div>
<div class="cell code" data-execution_count="13">
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>df_SP500[PSALES].describe()</span></code></pre></div>
<div class="output execute_result" data-execution_count="13">
<pre><code>count    10591.000000
mean         1.355346
std          0.403827
min          0.590104
25%          1.009636
50%          1.378226
75%          1.618272
max          2.218035
Name: P/Sales, dtype: float64</code></pre>
</div>
</div>
<div id="389b8eb0" class="cell markdown">
<p>You provided code that operates on a dataframe called "df_SP500". A
column called "PSALES" is extracted from the dataframe. This column is
then described using the ".describe()" method. The ".describe()" method
calculates and presents various statistical measures for the column.
Among these measures are the number of non-missing values, the mean
(average), the standard deviation, the minimum value, the 25th
percentile (a measure of the data distribution), the median (50th
percentile), and the 75th percentile. Using the ".describe()" method on
the "PSALES" column within the "df_SP500" dataframe, the code provides
statistical summary information. As a result of this summary, you can
gain insight into the distribution and central tendency of the data in
the "PSALES" column.</p>
</div>
<div class="cell markdown">
<p>Forecasting models consider growth in sales per share as an important
factor. Based on the following plot and statistics, the S&amp;P 500 has
had somewhat cyclical sales growth between 1989 and 2017, with the mean
at 3.7% and the extremes at -16.5% and 12.6%. As the forecasting model
assumes that the average sales growth is reasonably similar over longer
time-periods of e.g. five to ten years, the somewhat cyclical and
mean-reverting nature of the sales growth is important when fitting
historical data to the forecasting model.</p>
</div>
<div class="cell code" data-execution_count="14" data-scrolled="true">
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>df_SP500[SALES_GROWTH].plot(grid<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<div class="output execute_result" data-execution_count="14">
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f8862f39e48&gt;</code></pre>
</div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/2c6073bcb24a311caeddc709a45a2397b21ae536.png" /></p>
</div>
</div>
<div id="97f16959" class="cell markdown">
<p>It retrieves a specific column called "SALES_GROWTH" from a DataFrame
called "df_SP500". The "SALES_GROWTH" column is then visualized using
the plot() function. A grid is displayed on the plot to help align the
data points and simplify the visualization. In general, this code plots
the sales growth data from the "df_SP500" DataFrame.</p>
</div>
<div class="cell code" data-execution_count="15">
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>df_SP500[SALES_GROWTH].describe()</span></code></pre></div>
<div class="output execute_result" data-execution_count="15">
<pre><code>count    10415.000000
mean         0.037141
std          0.053362
min         -0.164586
25%          0.004295
50%          0.043822
75%          0.078067
max          0.125595
Name: Sales Growth, dtype: float64</code></pre>
</div>
</div>
<div id="ea5c338d" class="cell markdown">
<p>It performs descriptive statistics on a column
(<code>SALES_GROWTH</code>) in a dataframe (<code>df_SP500</code>). The
first step is to select the <code>SALES_GROWTH</code> column from the
<code>df_SP500</code> dataframe. It probably contains information about
the growth rates of different companies or stocks in the S&amp;P 500
index. After that, the <code>describe()</code> function is applied to
the <code>SALES_GROWTH</code> column. The function calculates various
summary statistics about the column's data. The most common statistics
are count (number of non-missing values), mean (average), standard
deviation, minimum, 25th percentile, median (50th percentile), 75th
percentile, and maximum. It can provide insight into the distribution
and characteristics of sales growth data for S&amp;P 500 companies if
you run this code.</p>
</div>
<div class="cell markdown">
<p>From 1989 to 2017, the following plot and statistics show the
historical dividend yield for the S&amp;P 500. Dividend yields ranged
from 1% to 4% with a mean of 2.1%. It is important to use matching data
periods for historical P/Sales ratios, sales growth, and dividend
yields, which we only have for 1989 for the S&amp;P 500.</p>
</div>
<div class="cell code" data-execution_count="16">
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>df_SP500[DIVIDEND_YIELD][<span class="st">&quot;1989&quot;</span>:].plot(grid<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<div class="output execute_result" data-execution_count="16">
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f886325f6d8&gt;</code></pre>
</div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/887076e12065146936665e3600c2c49429b14812.png" /></p>
</div>
</div>
<div id="23c5ae14" class="cell markdown">
<p>Using the pandas library, this code plots a line graph. There is a
specific column called "DIVIDEND_YIELD" in the dataset called
"df_SP500". From 1989 onwards, the graph will display data. This data is
visualized using the "plot" function. Gridlines are displayed in the
graph with the "grid=True" parameter. In general, this code plots the
dividend yield from the SP500 dataset starting in 1989.</p>
</div>
<div class="cell code" data-execution_count="17" data-scrolled="true">
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>df_SP500[DIVIDEND_YIELD][<span class="st">&quot;1989&quot;</span>:].describe()</span></code></pre></div>
<div class="output execute_result" data-execution_count="17">
<pre><code>count    10772.000000
mean         0.021157
std          0.006215
min          0.010819
25%          0.017290
50%          0.019661
75%          0.024518
max          0.040702
Name: Dividend Yield, dtype: float64</code></pre>
</div>
</div>
<div id="0934c87e" class="cell markdown">
<p>The code is referring to a dataframe called "df_SP500" and it is
performing some operations on a specific column called "DIVIDEND_YIELD."
The code begins by specifying a range of rows from 1989 to
present.<br />
This filtered range of rows is then described using the "describe()"
function.<br />
The "describe()" function calculates several statistical measures for
the "DIVIDEND_YIELD" column, including the count of values, mean,
standard deviation, minimum value, 25th percentile, median, 75th
percentile, and maximum value.<br />
Using the "df_SP500" dataframe, the output will provide a summary of
these statistical measures for the "DIVIDEND_YIELD" column.</p>
</div>
<div class="cell markdown">
<p>With the historical data for the S&amp;P 500 between 1989 and 2017,
we use the forecasting model. Blue dots indicate the actual one-year
returns of the S&amp;P 500. Black solid line represents forecasted mean
return. There is one standard deviation around the mean in the green
area, and two standard deviations around the mean in the red area. For
comparison, the dashed black line represents the mean annualized return
for the historical data.</p>
</div>
<div class="cell code" data-execution_count="18" data-scrolled="true">
<div class="sourceCode" id="cb24"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">1</span>, ticker<span class="op">=</span>ticker_SP500, df<span class="op">=</span>df_SP500)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/e1884a5b541f8f47d1c5d6d2db896e6429478e25.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	28.5%		12.2%		0.00e+00
R^2:	-4.08
</code></pre>
</div>
</div>
<div id="cadc425c" class="cell markdown">
<p>Plot_ann_returns(years=1, ticker=ticker_SP500, df=df_SP500) calls
plot_ann_returns with three arguments: years, ticker, and df. It is
being passed '1' for years, 'ticker_SP500' for ticker, and 'df_SP500' as
df for the df argument. Plotting annual returns for a specific stock or
financial asset is likely the purpose of plot_ann_returns. In the case
of <code>1</code> as the <code>years</code> argument, the function will
calculate and plot the annual returns for a one-year period. This
argument specifies the ticker symbol of the stock or asset, which in
this case is the S&amp;P 500. This argument likely represents a
dataframe that contains the asset's required data. By using the ticker
symbol and dataframe provided, this code plots the annual returns for a
given asset over a specific period of time.</p>
</div>
<div class="cell markdown">
<p>According to the statistics printed below the plot, the forecasting
model fits the historical data much worse than the baseline model. Based
on the Mean Absolute Error (MAE), the forecasting model has an average
absolute error of 28.5% versus 12.2% for the baseline. Since the p-value
is practically zero, this difference is not random. The forecasting
model therefore fits the historical data much worse than the average
return for 1-year investment periods of the S&amp;P 500. Also note that
the <span class="math inline"><em>R</em><sup>2</sup></span> is negative
because the variance is high for the data and the non-linear forecasting
model fits the data poorly. These statistical measures are explained in
more detail in .</p>
</div>
<div class="cell markdown">
<p>These plots were omitted since the forecasting model also fits the
data worse than the average annualized return for 2 and 3 year periods.
Graph showing the annualized return for all 4-year periods of the
S&amp;P 500, along with the forecasted mean and standard deviation.</p>
</div>
<div class="cell code" data-execution_count="19" data-scrolled="true">
<div class="sourceCode" id="cb26"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">4</span>, ticker<span class="op">=</span>ticker_SP500, df<span class="op">=</span>df_SP500)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/30b06854fa063bdf3de6ebec252fbaaa677f9dab.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	6.5%		8.5%		2.11e-164
R^2:	0.41
</code></pre>
</div>
</div>
<div id="5c4721c0" class="cell markdown">
<p>Using plot_ann_returns(years=4, ticker=ticker_SP500, df=df_SP500),
the code calls a function called plot_ann_returns with three arguments:
year, ticker, and df. The <code>years</code> argument indicates that the
function will calculate and plot the annual returns for a period of four
years. There is a ticker argument set to ticker_SP500, indicating that
the function will calculate S&amp;P 500 annual returns. DataFrame
df_SP500, which presumably contains historical data for the S&amp;P 500
index, is set as df_SP500. With these arguments, the function will
calculate the annual returns of the S&amp;P 500 index over the last four
years using historical data from the DataFrame df_SP500. After that, the
annual returns will be plotted in some visual format, such as a line
graph or bar chart. Essentially, this code analyzes and visualizes the
annual returns of the S&amp;P 500 index over time.</p>
</div>
<div class="cell markdown">
<p>We would like to quantify exactly how much better the forecasting
model fits than the baseline, which is shown in the above statistics.
Forecasting model MAE is 6.5%, baseline MAE is 8.5%. On average, the
forecasting model has a better fit with an absolute error of about 2
percentage points. It is extremely unlikely that this happened by chance
since the p-value is practically zero. However, the <span
class="math inline"><em>R</em><sup>2</sup></span> is only 0.41, which
means that most variance in the data is still not explained by the
forecasting model.</p>
</div>
<div class="cell markdown">
<p>As you can see in this plot, the actual returns of the S&amp;P 500
for all 10-year investment periods between 1989 and 2017 are almost all
within one standard deviation of the forecasted mean, so the forecasting
model fits quite well with the historical data. The <span
class="math inline"><em>R</em><sup>2</sup></span> value is 0.75, which
means that the forecasting model can explain a lot of variance in
data.</p>
</div>
<div class="cell code" data-execution_count="20" data-scrolled="false">
<div class="sourceCode" id="cb28"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">10</span>, ticker<span class="op">=</span>ticker_SP500, df<span class="op">=</span>df_SP500)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/3949ab310473f1c53c9b80bb3fae3c256a419eb6.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	2.1%		3.5%		1.10e-277
R^2:	0.75
</code></pre>
</div>
</div>
<div id="70b8026b" class="cell markdown">
<p>In the code above, the function call plot_ann_returns(years=10,
ticker=ticker_SP500, df=df_SP500) is called with three arguments:
<code>years</code>, <code>ticker</code>, and <code>df</code>. With a
value of 10, the function will calculate annual returns for a period of
10 years. The <code>ticker</code> argument is set to a variable called
<code>ticker_SP500</code>, which presumably contains the S&amp;P 500
index ticker symbol. As a result, the function will calculate S&amp;P
500 returns specifically. The <code>df</code> argument is set to a
variable called <code>df_SP500</code>, which is likely a dataframe or a
data structure holding historical index price data. The annual returns
will be calculated using this dataframe. Based on the provided
historical price data, it seems that the code generates a plot of the
annual returns for the S&amp;P 500 index over a ten-year period.</p>
</div>
<div class="cell markdown">
<p>Blue dots on the above plot show the actual 10-year returns for the
S&amp;P 500, but there are some irregularities. The S&amp;P 500 could be
at the peak of a bubble or at the bottom of a crash at the end of a
10-year period due to stock market bubbles and crashes. We can smooth
out the effects of daily noise and stock-market bubbles and crashes by
letting each blue dot represent an average annualized return for
investment periods between 6 and 10 years. The following plot shows the
original proposal in . There is a slightly better fit with <span
class="math inline"><em>R</em><sup>2</sup> = 0.83</span>.</p>
</div>
<div class="cell code" data-execution_count="21">
<div class="sourceCode" id="cb30"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">8</span>, years_range<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>                 ticker<span class="op">=</span>ticker_SP500, df<span class="op">=</span>df_SP500)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/5c27038115629461f4edea582b03ed750a0e079e.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	2.0%		5.1%		0.00e+00
R^2:	0.83
</code></pre>
</div>
</div>
<div id="ccd2343b" class="cell markdown">
<p>The code calls the function "plot_ann_returns" with four arguments:
years, years_range, ticker, and df. "years" is set to 8, "years_range"
to 2, "ticker" is set to a variable called "ticker_SP500", and "df" is
set to a variable called "df_SP500". "plot_ann_returns" plots the annual
returns of a specific stock or index based on these arguments. In this
case, 8 years of data will be plotted using the "years" argument.
Setting "years_range" to 2 would mean plotting the data from 2018 to
2020 if the data is available from 2010 to 2020. Probably the "ticker"
and "df" arguments specify the plot's data source. The "Ticker"
specifies the specific stock or market index to be plotted, in this
case, "ticker_SP500". "df" represents the dataset containing data for
the specified stock or index, in this case, "df_SP500". Overall, this
code is calling a function to plot the annual returns of a specific
stock or market index using a dataset containing the data for that stock
or index, with the number of years of data and the range of years to be
plotted.</p>
</div>
<div class="cell markdown">
<p>For comparison with other stock indices, this plot shows the
historical returns of the S&amp;P 500 averaged over three to seven-year
investment periods. There is a decent fit between the forecasting model
and the historical data with <span
class="math inline"><em>R</em><sup>2</sup> = 0.68</span>.</p>
</div>
<div class="cell code" data-execution_count="22">
<div class="sourceCode" id="cb32"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">5</span>, years_range<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>                 ticker<span class="op">=</span>ticker_SP500, df<span class="op">=</span>df_SP500)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/aa55209ac0c3ba0362c8daa60ab3b415d44e4279.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	3.8%		7.7%		0.00e+00
R^2:	0.68
</code></pre>
</div>
</div>
<div id="19afa50d" class="cell markdown">
<p>A plot of annual returns for a specific number of years, in this case
5, is generated by the code above. Plotting returns requires four
arguments: years, years_range, ticker, and df. In this case, the years
argument specifies the number of years for which the returns should be
plotted, which is 5. The years_range argument specifies the range of
years to include in the plot, which is set to 2. Consequently, the plot
will include returns for the most recent two years within the overall
5-year period. The ticker argument specifies the stock ticker symbol for
which returns should be plotted, in this case, ticker_SP500. df is a
dataframe containing historical stock price data for the specified
ticker. df_SP500 is the name of this dataframe. The code will generate a
plot showing the annual returns for the specified ticker over a 5-year
period, focusing on the most recent two years. The graph shows how the
stock has performed over time.</p>
</div>
<div class="cell markdown">
<p>There are 400 mid-sized companies in USA that make up the S&amp;P 400
index, with market capitalizations between USD 1.6-6.8 billion (see
).</p>
</div>
<div class="cell markdown">
<p>In the following plot, the share price and total return for the
S&amp;P 400 are compared between 1995 and 2017.</p>
</div>
<div class="cell code" data-execution_count="23">
<div class="sourceCode" id="cb34"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>plot_price_total_return(df<span class="op">=</span>df_SP400[<span class="st">&quot;1995&quot;</span>:])</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/791c152e6a597ba18c29d2d8061b4a0c5eec2d3b.png" /></p>
</div>
</div>
<div id="5943fa15" class="cell markdown">
<p>As an argument, "df" is passed to a function called
"plot_price_total_return()". DataFrame "df" appears to be a subset of
"df_SP400", including 1995 data. In the code snippet provided, there is
no indication of the specific functionality of
"plot_price_total_return()". According to the name of the function, it
is likely that the function plots the total return of the prices in the
DataFrame "df". It means that the function has already been defined
somewhere else in the code since the code snippet is a function call. It
is necessary to examine the definition of the
"plot_price_total_return()" function to fully understand what the code
does.</p>
</div>
<div class="cell markdown">
<p>P/S ratios for the S&amp;P 400 between 1995 and 2017 are shown in the
following plot and statistics. P/Sales ratios ranged from 0.5 to 1.4
with a mean of 1.1.</p>
</div>
<div class="cell code" data-execution_count="24">
<div class="sourceCode" id="cb35"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>df_SP400[PSALES].plot(grid<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<div class="output execute_result" data-execution_count="24">
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f8860f5ed68&gt;</code></pre>
</div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/38b6f8b9539fdd20f5a674e749d3e32ee6ac7f99.png" /></p>
</div>
</div>
<div id="b5d823c3" class="cell markdown">
<p>Python code snippet df_SP400 performs a specific task on a pandas
DataFrame object named df_SP400. Plot() is called with the argument
PSALES, which indicates a specific column within the DataFrame that
contains sales data. Line graphs are created using the code. By passing
the argument grid=True, the plot() function adds a grid to the graph for
easy visual reference. To visualize the sales trends, this code takes
the PSALES column from the df_SP400 DataFrame and generates a line graph
with a grid.</p>
</div>
<div class="cell code" data-execution_count="25">
<div class="sourceCode" id="cb37"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>df_SP400[PSALES].describe()</span></code></pre></div>
<div class="output execute_result" data-execution_count="25">
<pre><code>count    8037.000000
mean        1.103492
std         0.146182
min         0.508140
25%         1.020054
50%         1.123266
75%         1.201071
max         1.415186
Name: P/Sales, dtype: float64</code></pre>
</div>
</div>
<div id="e5b38399" class="cell markdown">
<p>The code <code>df_SP400[PSALES].describe()</code> performs a specific
operation on the DataFrame <code>df_SP400</code>. In the first step, an
indexing operation called [PSALES] is used to select a specific column
or series from the DataFrame. Having selected the specific column, the
<code>.describe()</code> function is applied to it. The function
calculates summary statistics for the selected column of data. As a
result, the output will display the number of non-null values, the mean,
standard deviation, minimum and maximum values, as well as lower
quartile, median, and upper quartile values. As a result of this
information, we can better understand the distributions and
characteristics of the data in the PSALES column.</p>
</div>
<div class="cell markdown">
<p>For the S&amp;P 400, the annual growth in Sales Per Share has ranged
from -28% to +10% with an average of 8.7%.</p>
</div>
<div class="cell code" data-execution_count="26">
<div class="sourceCode" id="cb39"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>df_SP400[SALES_GROWTH].plot(grid<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<div class="output execute_result" data-execution_count="26">
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f8860dcdb38&gt;</code></pre>
</div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/6bca5ea5dede549b15d36a536ab62ebe4a1df804.png" /></p>
</div>
</div>
<div id="4cfdd6d9" class="cell markdown">
<p>DataFrame "df_SP400" is used to plot sales growth data. Here is a
step-by-step explanation of what the code does: The code plots
"df_SP400[SALES_GROWTH]". In the DataFrame, "SALES_GROWTH" refers to a
column that contains sales growth values.<br />
To generate a plot, the .plot() function is called on the specified
data. Most likely, this function is part of a plotting library or
module.<br />
Gridlines are included in the plot when the "grid=True" parameter is set
to true. The plotted data can be visually aligned and interpreted by
using gridlines. The code plots the sales growth data from the
"df_SP400" DataFrame. There will likely be a plot with sales growth
values on the y-axis and categorical or numerical labels on the x-axis.
Incorporating gridlines will make the plot easier to interpret and
analyze.</p>
</div>
<div class="cell code" data-execution_count="27">
<div class="sourceCode" id="cb41"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>df_SP400[SALES_GROWTH].describe()</span></code></pre></div>
<div class="output execute_result" data-execution_count="27">
<pre><code>count    7873.000000
mean        0.086952
std         0.066265
min        -0.109900
25%         0.050749
50%         0.086885
75%         0.121823
max         0.280169
Name: Sales Growth, dtype: float64</code></pre>
</div>
</div>
<div id="1f2063c8" class="cell markdown">
<p>Your code performs a specific action on a DataFrame called df_SP400.
It applies the describe() method to the column SALES_GROWTH within the
DataFrame. Data in a column can be described using the describe()
method. It includes the count, the mean (average), the standard
deviation, the minimum and maximum values, as well as the first
quartile, median (second quartile), and third quartile. The code
generates and displays these descriptive statistics by applying the
describe() method to the SALES_GROWTH column in the df_SP400 DataFrame.
The SALES_GROWTH column of the DataFrame contains information about the
distribution and characteristics of sales growth data.</p>
</div>
<div class="cell markdown">
<p>Dividend yields for the S&amp;P 400 between 1995 and 2018 ranged
between 1% and 2.8% with a mean of 1.3%.</p>
</div>
<div class="cell code" data-execution_count="28">
<div class="sourceCode" id="cb43"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>df_SP400[DIVIDEND_YIELD][<span class="st">&quot;1995&quot;</span>:].plot(grid<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<div class="output execute_result" data-execution_count="28">
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f8862b8e390&gt;</code></pre>
</div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/f332aa8576ba55f1038b8b60b119bf99e07f4fec.png" /></p>
</div>
</div>
<div id="dd09fbcc" class="cell markdown">
<p>You provided code that performs a series of actions on the dataframe
df_SP400. From the dataframe, it accesses a column named DIVIDEND_YIELD.
The dataframe is then subset starting from 1995 until the end. All data
prior to 1995 is filtered out. It then plots the filtered data as a line
graph. It includes a grid to make it easier to read and interpret. In
summary, this code visualizes the dividend yield over time, highlighting
changes and trends in dividend yields since 1995.</p>
</div>
<div class="cell code" data-execution_count="29" data-scrolled="true">
<div class="sourceCode" id="cb45"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>df_SP400[DIVIDEND_YIELD][<span class="st">&quot;1995&quot;</span>:].describe()</span></code></pre></div>
<div class="output execute_result" data-execution_count="29">
<pre><code>count    8582.000000
mean        0.013293
std         0.002787
min         0.009265
25%         0.011115
50%         0.013160
75%         0.014702
max         0.028419
Name: Dividend Yield, dtype: float64</code></pre>
</div>
</div>
<div id="d430ef68" class="cell markdown">
<p>In this code, a variable called "df_SP400" is referenced and an
operation is performed on it. "df_SP400" is likely a Pandas DataFrame
object, which is a Python data structure for storing and analysing data.
DataFrame data is being described using the "describe()" method. A
column called "DIVIDEND_YIELD" is being described using the "describe()"
method. It is likely that this column contains information about the
dividend yield of certain stocks or assets. In the "DIVIDEND_YIELD"
column, the square brackets ["1995":] specify a specific range of data.
It is selecting data from 1995 onwards in this case. Overall, this code
retrieves the descriptive statistics of dividend yield data from the
"DIVIDEND_YIELD" column of the "df_SP400" DataFrame, specifically from
1995 onward. Descriptive statistics could include measures such as mean,
median, standard deviation, minimum, and maximum dividend yields.</p>
</div>
<div class="cell markdown">
<p>In the plot below, blue dots represent the actual historical 1-year
returns of the S&amp;P 400. This model's forecasted mean has a very poor
fit to the historical data, as shown by the solid black line.</p>
</div>
<div class="cell code" data-execution_count="30" data-scrolled="true">
<div class="sourceCode" id="cb47"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">1</span>, ticker<span class="op">=</span>ticker_SP400, df<span class="op">=</span>df_SP400)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/942fc13ad40740880bad4a66ddf12ea90a892f5b.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	14.6%		13.6%		1.19e-15
R^2:	-0.12
</code></pre>
</div>
</div>
<div id="071c363d" class="cell markdown">
<p>The function plot_ann_returns(years=1, ticker=ticker_SP400,
df=df_SP400) plots the annual returns for a given stock ticker symbol
over a specified number of years. There are three parameters in the
function: 'years', 'ticker', and 'df'.<br />
The first parameter specifies the number of years for which annual
returns will be calculated. This parameter represents the stock ticker
symbol for which the returns will be calculated. This parameter is a
DataFrame containing historical price data for the specified stock. With
the historical price data from the df DataFrame, plot_ann_returns()
calculates the annual returns for the specified stock ticker symbol. On
a graph, the x-axis represents the different years, and the y-axis
represents the corresponding annual returns. A plot is displayed,
allowing the user to visualize the annual returns for the specified
stock ticker symbol.</p>
</div>
<div class="cell markdown">
<p>The following plot shows the historical 3-year returns of the S&amp;P
400, which starts to fit the forecasting model, but <span
class="math inline"><em>R</em><sup>2</sup> = 0.32</span> so most of the
data's variance is still unexplained.</p>
</div>
<div class="cell code" data-execution_count="31">
<div class="sourceCode" id="cb49"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">3</span>, ticker<span class="op">=</span>ticker_SP400, df<span class="op">=</span>df_SP400)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/001722bae53becffed9c213c92d276f38aa1779d.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	5.9%		6.8%		6.50e-83
R^2:	0.32
</code></pre>
</div>
</div>
<div id="21220d60" class="cell markdown">
<p>In your code, you are calling a function called "plot_ann_returns"
with three arguments. "Years" is set to 3 in the first argument. Based
on this, the function will calculate annual returns for a period of
three years. In the second argument, "ticker", the value is
"ticker_SP400". This argument probably represents the ticker symbol of a
stock or index, possibly the S&amp;P 400. "df_SP400" is set as the third
argument. For calculating the annual returns, this argument is probably
a DataFrame. According to the function name and arguments provided, the
code plots annual returns for the given ticker (S&amp;P 400 in this
case) using the data from the DataFrame "df_SP400". A plot of the annual
returns will provide a visual representation, allowing for easier
analysis and interpretation.</p>
</div>
<div class="cell markdown">
<p>Below is a plot showing the S&amp;P 400's historical 5-year returns.
With the exception of a cluster of outliers with P/Sales ratios around
1, this probably represents the 5-year period between 2004 and 2009,
which ended with the financial crisis.</p>
</div>
<div class="cell code" data-execution_count="32">
<div class="sourceCode" id="cb51"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">5</span>, ticker<span class="op">=</span>ticker_SP400, df<span class="op">=</span>df_SP400)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/3c9e15956e2158df52027554832c450443467a76.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	2.9%		4.6%		0.00e+00
R^2:	0.56
</code></pre>
</div>
</div>
<div id="034018c6" class="cell markdown">
<p>It calls a function called plot_ann_returns with three arguments:
years, tickers, and df. This argument is set to 5, the ticker argument
is set to ticker_SP400, and the df argument is set to df_SP400. It is
likely used to plot the annual returns for a specific stock or financial
instrument. Passing the value '5' for the 'years' argument will plot the
annual returns for the past five years. The <code>ticker</code> argument
is probably a variable holding the ticker symbol of the financial
instrument or stock we want to plot. It could be something like "AAPL"
for Apple Inc. For Google, use "GOOGL". df is likely a variable that
holds a DataFrame or some other data structure that contains historical
price data for the stock. Calculating the annual returns requires this
data. With the specified arguments, it will generate a plot showing the
annual returns for the specified stock or financial instrument over the
last five years. Over time, this can be useful for analyzing stock or
instrument performance.</p>
</div>
<div class="cell markdown">
<p>By considering the mean annualized return over three to seven years,
we can smooth out the impact of stock market bubbles and crashes. As
shown in the following plot, the forecasting model fits fairly well with
<span class="math inline"><em>R</em><sup>2</sup> = 0.60</span>.</p>
</div>
<div class="cell code" data-execution_count="33">
<div class="sourceCode" id="cb53"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">5</span>, years_range<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>                 ticker<span class="op">=</span>ticker_SP400, df<span class="op">=</span>df_SP400)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/db6f468fa45adbcc6a91f2474fcfe0eae37810c1.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	2.7%		3.9%		1.92e-185
R^2:	0.60
</code></pre>
</div>
</div>
<div id="1e6fcdb0" class="cell markdown">
<p>A function called "plot_ann_returns" is being called with four
arguments - "years", "years_range", "ticker", and "df". "years" is
assigned a value of 5, "years_range" is assigned a value of 2, "ticker"
is assigned a value of ticker_SP400, and "df" is assigned a value of
df_SP400. This function plots a number of years' worth of annual
returns. The "years" argument specifies the number of years for which
the returns will be plotted. It is set to 5 in this case. The
"years_range" argument determines how many years of returns will be
displayed at a time on the plot. It is set to 2 in this case. "ticker"
represents the ticker symbol for the dataset that will be plotted. It
appears that ticker_SP400 represents the S&amp;P 400 index ticker symbol
in this case. As the value of df_SP400, the "df" argument represents the
dataset itself. For calculating and plotting the annual returns, this
dataset is likely to contain the necessary information. Overall, this
code plots the annual returns for a specific number of years using a
specific dataset and ticker symbol.</p>
</div>
<div class="cell markdown">
<p>This plot shows the S&amp;P 400 over 10-year investment periods,
which does not fit well with the forecasting model. Further research is
needed to determine the reason.</p>
</div>
<div class="cell code" data-execution_count="34">
<div class="sourceCode" id="cb55"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">10</span>, ticker<span class="op">=</span>ticker_SP400, df<span class="op">=</span>df_SP400)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/d37bcf4b175eb2db3037f8b0bb5b5f80dc7ae34e.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	2.0%		1.8%		1.05e-16
R^2:	-0.26
</code></pre>
</div>
</div>
<div id="84cfa964" class="cell markdown">
<p>It calls a function named "plot_ann_returns" with three arguments:
"years", "ticker", and "df". Years is set to 10, ticker is a variable
named "ticker_SP400", and df is a variable named "df_SP400". This
function plots the annual returns of a specific stock or financial
instrument over a specified period of time. The "years" argument
specifies the duration of the analysis, while the "ticker" argument
specifies the stock or instrument to analyze. "df" represents the data
associated with the specified stock or instrument. For the specified
number of years, the function will calculate the annual returns based on
the supplied data. A graph or a plot will then be generated that shows
the annual returns over time. Stocks and instruments can be analyzed in
this way to determine their performance and volatility.</p>
</div>
<div class="cell markdown">
<p>The S&amp;P 600 index consists of 600 small-sized companies in the
USA with market capitalizations between USD 0.5 and $5 billion (see
).</p>
</div>
<div class="cell markdown">
<p>From 1995 to 2017, the following plot compares the share price and
total return of the S&amp;P 600.</p>
</div>
<div class="cell code" data-execution_count="35">
<div class="sourceCode" id="cb57"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>plot_price_total_return(df<span class="op">=</span>df_SP600[<span class="st">&quot;1995&quot;</span>:])</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/3caa22a7f5d6a4bb73bcfb3d6faa639ce45c07fb.png" /></p>
</div>
</div>
<div id="2647c421" class="cell markdown">
<p>A DataFrame is passed into a function called
"plot_price_total_return". By indexing another DataFrame called df_SP600
with the string "1995", we get the DataFrame that only contains 1995
data. This function plots the total return of a stock or investment over
time. The total return for each point in time is computed using the
input DataFrame. The total return over the specified period is then
visualized using a plot. According to the code, the total return should
be plotted for the DataFrame starting in 1995. The intention is to
observe the total return of a stock or investment starting from that
year onward. This code plots the total return over time for a DataFrame
containing historical price data, providing a visual representation of
the performance of the investment.</p>
</div>
<div class="cell markdown">
<p>P/S ratios for the S&amp;P 600 between 1995 and 2017 are plotted in
the following plot and statistics. P/Sales ranged from 0.4 to 1.25, with
a mean of 0.9.</p>
</div>
<div class="cell code" data-execution_count="36">
<div class="sourceCode" id="cb58"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>df_SP600[PSALES].plot(grid<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<div class="output execute_result" data-execution_count="36">
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f8862b73390&gt;</code></pre>
</div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/33d1f840c2c0d4dc217522afa5f8aabb5e0813cb.png" /></p>
</div>
</div>
<div id="6b7bce6d" class="cell markdown">
<p>Your code plots a line graph. df_SP600[PSALES] is a dataset or
dataframe containing sales data. This code plots the column labeled as
"PSALES" from the dataset. A line graph is generated using the plot()
function on this column. A line graph shows the PSALES values on the
y-axis and the index or x-axis values of the dataset on the x-axis. This
parameter adds a grid to the plot, making it easier to read and
interpret the graph.</p>
</div>
<div class="cell code" data-execution_count="37">
<div class="sourceCode" id="cb60"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>df_SP600[PSALES].describe()</span></code></pre></div>
<div class="output execute_result" data-execution_count="37">
<pre><code>count    8037.000000
mean        0.918666
std         0.154023
min         0.409077
25%         0.809512
50%         0.920284
75%         1.034259
max         1.248116
Name: P/Sales, dtype: float64</code></pre>
</div>
</div>
<div id="6f52a79e" class="cell markdown">
<p>df_SP600[PSALES] selects a column called "PSALES" from the dataframe
named df_SP600. Once this column is selected, the
<code>.describe()</code> function is applied to it. The descriptors
calculated by the describe() function are various descriptive statistics
for the selected column. Among the information provided is count, which
indicates how many non-null values are in the column, mean, which
measures how much the column varies or disperses, standard deviation,
which measures how much variation is present in the column, minimum and
maximum values, as well as quartiles, which divide the data into four
equal parts. The code summarizes the statistical measures for the
"PSALES" column in the <code>df_SP600</code> dataframe.</p>
</div>
<div class="cell markdown">
<p>Here are the historical annual growth rates in Sales Per Share for
the S&amp;P 600, which ranged from -13% to +23%.</p>
</div>
<div class="cell code" data-execution_count="38">
<div class="sourceCode" id="cb62"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>df_SP600[SALES_GROWTH].plot(grid<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<div class="output execute_result" data-execution_count="38">
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f886106f860&gt;</code></pre>
</div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/3a8b55beecc39f63e710c1c03973241b078d0127.png" /></p>
</div>
</div>
<div id="c8cd8260" class="cell markdown">
<p>Data from the column "SALES_GROWTH" in the dataframe "df_SP600" is
plotted using this code. The code first selects the column
"SALES_GROWTH" from the dataframe "df_SP600". A line graph is then
created based on this data. On the y-axis, the graph will display the
sales growth values from the "SALES_GROWTH" column, and on the x-axis,
the dataframe index values. In addition to the "plot" function, there is
also a "grid=True" parameter, which adds a grid to the graph for ease of
reading. In general, this code visualizes the "SALES_GROWTH" column from
the "df_SP600" dataframe.</p>
</div>
<div class="cell code" data-execution_count="39">
<div class="sourceCode" id="cb64"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>df_SP600[SALES_GROWTH].describe()</span></code></pre></div>
<div class="output execute_result" data-execution_count="39">
<pre><code>count    7873.000000
mean        0.082902
std         0.066896
min        -0.134935
25%         0.054608
50%         0.087807
75%         0.121448
max         0.233809
Name: Sales Growth, dtype: float64</code></pre>
</div>
</div>
<div id="5bad6991" class="cell markdown">
<p>In a DataFrame named df_SP600, this line of code generates a summary
of descriptive statistics for a specific column, SALES_GROWTH. The first
thing it does is access the SALES_GROWTH column within the df_SP600
DataFrame. Following that, it calculates several summary statistics for
this column, such as the count (number of non-null values), mean,
standard deviation, minimum and maximum values, and percentiles (25th,
50th, 75th). A clear understanding of the distribution and
characteristics of SALES_GROWTH can be gained from this information.</p>
</div>
<div class="cell markdown">
<p>This plot shows the historical dividend yield for the S&amp;P 600
between 1995 and 2018, which ranged from 0.6% to 2.5%.</p>
</div>
<div class="cell code" data-execution_count="40">
<div class="sourceCode" id="cb66"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>df_SP600[DIVIDEND_YIELD][<span class="st">&quot;1995&quot;</span>:].plot(grid<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<div class="output execute_result" data-execution_count="40">
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f886095d7b8&gt;</code></pre>
</div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/a3fbaaaf919ac91ecd5ed06aa06ca12dacbbe233.png" /></p>
</div>
</div>
<div id="6ba7fde8" class="cell markdown">
<p>This code plots a graph based on the data in the dataframe
<code>df_SP600</code>. Dividend yield is the specific data used for the
plot. From 1995 onwards, the plot will only include data. To make it
easier to read and interpret, the graph will have a grid.</p>
</div>
<div class="cell code" data-execution_count="41" data-scrolled="true">
<div class="sourceCode" id="cb68"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>df_SP600[DIVIDEND_YIELD][<span class="st">&quot;1995&quot;</span>:].describe()</span></code></pre></div>
<div class="output execute_result" data-execution_count="41">
<pre><code>count    8582.000000
mean        0.010073
std         0.002635
min         0.006130
25%         0.008078
50%         0.009411
75%         0.011777
max         0.025011
Name: Dividend Yield, dtype: float64</code></pre>
</div>
</div>
<div id="35ad7c5a" class="cell markdown">
<p>This code describes some statistical information about the SP600
DataFrame's dividend yield data. Here is a step-by-step explanation of
what this code does: Get the dataframe "df_SP600". From the dataframe,
retrieve the column "DIVIDEND_YIELD". Only include values starting in
1995 and onwards in the data. This filtered data can be described using
the "describe()" function. "describe()" generates descriptive statistics
that summarize the central tendency, dispersion, and shape of a dataset.
This statistical information includes the count (number of values), mean
(average), standard deviation, minimum value, 25th percentile, median
(50th percentile), 75th percentile, and maximum value of dividend yield
data from 1995 onwards. Summary: The code below provides statistical
information about the dividend yield data of the SP600 DataFrame since
1995.</p>
</div>
<div class="cell markdown">
<p>In the following plot, blue dots represent the actual historical
1-year returns of the S&amp;P 600. Compared to historical returns, the
model's forecasted mean has a very poor fit.</p>
</div>
<div class="cell code" data-execution_count="42" data-scrolled="true">
<div class="sourceCode" id="cb70"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">1</span>, ticker<span class="op">=</span>ticker_SP600, df<span class="op">=</span>df_SP600)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/bb49e5877dc12ed6935ff6ca2efb20bd0074dc49.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	17.9%		14.1%		1.01e-116
R^2:	-0.46
</code></pre>
</div>
</div>
<div id="654b1005" class="cell markdown">
<p>Plot_ann_returns(years=1, ticker=ticker_SP600, df=df_SP600) calls
plot_ann_returns, which takes three parameters: years, ticker, and df.
If the year parameter is set to 1, the function calculates one-year
returns. In this case, ticker is being set to ticker_SP600, which is
likely a stock or financial index, such as the S&amp;P 600 SmallCap
Index. The <code>df</code> parameter is set to <code>df_SP600</code>,
which probably represents a dataframe or dataset containing the required
data for calculating the returns. Using the provided data, this code
calculates and plots the annual returns for a specific stock or index.
Plot_ann_returns contains specific details about how the returns are
calculated and plotted, which is not shown in the code snippet.</p>
</div>
<div class="cell markdown">
<p>Plotting the historical 3-year return of the S&amp;P 600 starts to
fit the forecasting model, but the Goodness of Fit for the model is
relatively low at 0.24, leaving most of the variance unexplained.</p>
</div>
<div class="cell code" data-execution_count="43">
<div class="sourceCode" id="cb72"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">3</span>, ticker<span class="op">=</span>ticker_SP600, df<span class="op">=</span>df_SP600)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/45286d5284113ec9d790997f34a7d8ee569779d8.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	6.6%		6.9%		1.06e-09
R^2:	0.24
</code></pre>
</div>
</div>
<div id="f87f0be3" class="cell markdown">
<p>The code
<code>plot_ann_returns(years=3, ticker=ticker_SP600, df=df_SP600)</code>
calls a function named <code>plot_ann_returns</code>. There are three
arguments to this function: years, ticker, and df. The
<code>years</code> argument is set to 3, which means the code requests
to plot the annual returns for 3 years. The <code>ticker</code> argument
is set to <code>ticker_SP600</code>, indicating that the code uses the
S&amp;P 600 index ticker symbol. Financial markets use this ticker
symbol to refer to a specific stock or index. Using this argument, the
code presumably uses df_SP600, which contains historical stock data for
the S&amp;P 600 index. By calling a function with the respective ticker
symbol and dataframe, this code plots the annual returns of the S&amp;P
600 index for a specific period of three years.</p>
</div>
<div class="cell markdown">
<p>Below is a plot of S&amp;P 600 returns over the past five years. With
the exception of a few outliers with P/Sales ratios around 0.95, it fits
the forecasting model reasonably well. In the same way as the S&amp;P
400, this was probably the period between 2004 and 2009, which
culminated in a stock-market crash.</p>
</div>
<div class="cell code" data-execution_count="44">
<div class="sourceCode" id="cb74"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">5</span>, ticker<span class="op">=</span>ticker_SP600, df<span class="op">=</span>df_SP600)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/2c78adc246c8086bdcdb7a228410a45277e35d46.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	3.4%		5.3%		0.00e+00
R^2:	0.57
</code></pre>
</div>
</div>
<div id="e7591a13" class="cell markdown">
<p>Plot_ann_returns(years=5, ticker=ticker_SP600, df=df_SP600) calls
plot_ann_returns with three arguments: years, ticker, and df. The
<code>years</code> argument is set to five. In this example, the ticker
argument is set to a variable named ticker_SP600, and the df argument is
set to a variable named df_SP600. Using this code, you can plot the
annual returns of a specific stock or financial asset over time. The
variable <code>years</code> indicates how many years of data we would
like to plot. The <code>ticker</code> variable represents the specific
stock or financial asset we are interested in, and the <code>df</code>
variable represents the data frame which contains the historical returns
data. With the plot_ann_returns function, we can visualize the annual
returns of the chosen stock or asset over the specified number of years.
It is assumed that the plot_ann_returns function will generate the
appropriate plot using the given data despite the lack of details in the
code snippet.</p>
</div>
<div class="cell markdown">
<p>By considering the mean annualized return for e.g. 3-7 year
investment periods, we can smooth out the effect of stock-market bubbles
and crashes. Based on the following plot, the forecasting model fits
fairly well with <span
class="math inline"><em>R</em><sup>2</sup> = 0.65</span>.</p>
</div>
<div class="cell code" data-execution_count="45">
<div class="sourceCode" id="cb76"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">5</span>, years_range<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>                 ticker<span class="op">=</span>ticker_SP600, df<span class="op">=</span>df_SP600)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/9eee82ae874844256d1df859f9aecb4915b591c6.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	2.8%		4.4%		3.68e-302
R^2:	0.65
</code></pre>
</div>
</div>
<div id="de9a5dac" class="cell markdown">
<p>Four parameters are passed to a function called plot_ann_returns.
With the first parameter set to 5, we will plot annual returns over a
five-year period. The second parameter, <code>years_range</code>,
indicates that each range of the x-axis represents a period of two
years. It is set to a variable called ticker_SP600, which probably
identifies a specific stock or index as the third parameter, ticker.
df_SP600 is set as the fourth parameter, which represents a DataFrame
containing data about stocks. A plot of annual returns over a specified
period of time is generated by the function plot_ann_returns in the
provided code snippet. From the code snippet alone, it is impossible to
determine how the plot is generated, what data is plotted, and how it
looks.</p>
</div>
<div class="cell markdown">
<p>In the following plot, the S&amp;P 600 for 10-year investment periods
does not fit the forecasting model very well. It is unclear why this is
happening and more research is needed.</p>
</div>
<div class="cell code" data-execution_count="46">
<div class="sourceCode" id="cb78"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">10</span>, ticker<span class="op">=</span>ticker_SP600, df<span class="op">=</span>df_SP600)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/03c97a39665f944740fdc5b987ac5030e7329f0e.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	2.1%		1.5%		2.29e-105
R^2:	-0.94
</code></pre>
</div>
</div>
<div id="a8a3d8f8" class="cell markdown">
<p>Your code calls a function called "plot_ann_returns" and passes three
arguments: "years", "ticker", and "df". Over a specified number of
years, this function plots the annual returns of a stock or financial
instrument. With "years" set to 10, it plots annual returns over a
period of 10 years. 'ticker' appears to be a variable or object
representing a specific stock or financial instrument. This parameter is
likely passed to the function to specify which stock or instrument's
returns should be plotted. In the third argument, "df", the stock or
instrument specified in "ticker" is also represented by a variable or
object, presumably a DataFrame. There is likely to be information in
this DataFrame, such as the date and corresponding returns. It calls a
function to plot the annual returns for a specified stock or instrument
over a specified period, using the data provided in a DataFrame.</p>
</div>
<div class="cell markdown">
<p>On the NASDAQ exchange, the NASDAQ 100 index contains 100 of the
largest non-financial stocks. Since we do not have data for the NASDAQ
100 index itself, we use data from an Exchange Traded Fund (ETF) with
the ticker symbol QQQ to track it.</p>
</div>
<div class="cell markdown">
<p>In the following plot, we compare share-price and total return for
the S&amp;P 600 between 2002 and 2019, the same period for which we have
the other financial data.</p>
</div>
<div class="cell code" data-execution_count="47">
<div class="sourceCode" id="cb80"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>plot_price_total_return(df<span class="op">=</span>df_QQQ[<span class="st">&quot;2002&quot;</span>:])</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/05566a73604234138255b93263825ad03684a3ad.png" /></p>
</div>
</div>
<div id="a4dda25a" class="cell markdown">
<p>Based on a given DataFrame called "df", the code you provided plots
the total return of a particular financial instrument, specifically a
stock or ETF. Here are the steps this code would undertake: Access the
variable "df_QQQ", which contains historical price data. Using the
indexing syntax ["2002":], we extract a subset of the DataFrame starting
from 2002. The dataframe subset is then passed as an argument to
plot_price_total_return(). Based on the provided data, the function
calculates the total return of the financial instrument. Using this
total return data, a visual representation of the instrument's
performance is generated. Typically, the x-axis represents the time
period and the y-axis represents the total return. This code generates a
plot that visually displays the total return of a specified financial
instrument beginning in 2002.</p>
</div>
<div class="cell markdown">
<p>Here are the historical P/S ratios for the NASDAQ 100 between 2002
and 2019. With a mean of 2.9, the P/S ratio ranged from 1.4 to 4.1.</p>
</div>
<div class="cell code" data-execution_count="48">
<div class="sourceCode" id="cb81"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>df_QQQ[PSALES].plot(grid<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<div class="output execute_result" data-execution_count="48">
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f8860639588&gt;</code></pre>
</div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/b436c46cda88f21e3faf8fc31c8c8239c204f890.png" /></p>
</div>
</div>
<div id="529638e7" class="cell markdown">
<p>A graph is plotted using the pandas DataFrame <code>df_QQQ</code> and
the column <code>PSALES</code>. This column is plotted by calling the
plot() function. Gridlines can be added to the graph using the grid=True
parameter, which can assist with data interpretation. It visualizes the
data from the <code>PSALES</code> column in the <code>df_QQQ</code>
DataFrame.</p>
</div>
<div class="cell code" data-execution_count="49">
<div class="sourceCode" id="cb83"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>df_QQQ[PSALES].describe()</span></code></pre></div>
<div class="output execute_result" data-execution_count="49">
<pre><code>count    6179.000000
mean        2.858183
std         0.509177
min         1.387867
25%         2.465714
50%         2.915132
75%         3.135186
max         4.124833
Name: P/Sales, dtype: float64</code></pre>
</div>
</div>
<div id="689f2d06" class="cell markdown">
<p>A DataFrame called "df_QQQ" contains a column called "PSALES". This
line of code gets statistical information about that column. The first
thing it will do is retrieve the column "PSALES" from the DataFrame
"df_QQQ". Afterwards, it will calculate and provide several descriptive
statistics for the "PSALES" column. The statistics include count, mean,
standard deviation, minimum value, 25th percentile, median, 75th
percentile, and maximum value. Understanding the distribution and range
of values in the "PSALES" column provides insight into the data's
central tendency and variability.</p>
</div>
<div class="cell markdown">
<p>In the following plot and statistics, the historical annual growth in
Sales Per Share for the NASDAQ 100 is shown, which has ranged from -2%
to +33% with a mean of 11.4%.</p>
</div>
<div class="cell code" data-execution_count="50">
<div class="sourceCode" id="cb85"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>df_QQQ[SALES_GROWTH].plot(grid<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<div class="output execute_result" data-execution_count="50">
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f886055e0f0&gt;</code></pre>
</div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/146da9327fbe6d39ad246aa0ef014038ed2f8acc.png" /></p>
</div>
</div>
<div id="49359b53" class="cell markdown">
<p>A data frame called 'df_QQQ' contains data stored in the
'SALES_GROWTH' column. To make it easier to read and interpret, the plot
will have a grid. On the basis of the values stored in the
'SALES_GROWTH' column, the plot will likely show the trend or pattern of
sales growth over time. For analysis or decision-making, the plot can
help identify increases and decreases in sales growth.</p>
</div>
<div class="cell code" data-execution_count="51">
<div class="sourceCode" id="cb87"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>df_QQQ[SALES_GROWTH].describe()</span></code></pre></div>
<div class="output execute_result" data-execution_count="51">
<pre><code>count    5839.000000
mean        0.114218
std         0.074280
min        -0.020979
25%         0.050689
50%         0.098598
75%         0.173477
max         0.334211
Name: Sales Growth, dtype: float64</code></pre>
</div>
</div>
<div id="0374da67" class="cell markdown">
<p>The code df_QQQ[SALES_GROWTH].describe() returns a statistical
summary of the Sales Growth column in the DataFrame df_QQQ. The first
step is to select the column "SALES_GROWTH" from the DataFrame
<code>df_QQQ</code>. The column contains information about a company's
or product's sales growth. It then applies the <code>describe()</code>
method to the selected column. In this method, various statistics are
calculated on the data in the column and a summary of these statistics
is returned. The summary includes basic statistics such as count, which
tells us the number of non-missing values in the column; mean, which
gives us the average value of the sales growth; standard deviation,
which measures the dispersion or variability of the sales growth values;
minimum and maximum values, representing the lowest and highest values
in the column; as well as quartiles, which divide the data into four
equal parts, providing us with a sense of how the data are distributed.
This code shows us the sales growth data in the "SALES_GROWTH" column in
the <code>df_QQQ</code> DataFrame.</p>
</div>
<div class="cell markdown">
<p>Between 2002 and 2019, the historical dividend yield for the NASDAQ
100 ranged between 0.0% and 2.1% with a mean of 0.8%.</p>
</div>
<div class="cell code" data-execution_count="52" data-scrolled="true">
<div class="sourceCode" id="cb89"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>df_QQQ[DIVIDEND_YIELD][<span class="st">&quot;2002&quot;</span>:].plot(grid<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<div class="output execute_result" data-execution_count="52">
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f88603f6fd0&gt;</code></pre>
</div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/4221274eff45e8a1151448758cd7559ab1f9d796.png" /></p>
</div>
</div>
<div id="d59c6b64" class="cell markdown">
<p>In Python, the given code plots a graph based on a column in a
DataFrame (df_QQQ). "DIVIDEND_YIELD" is the column used for plotting.
The following is a step-by-step breakdown of what the code does: 1. In
this code, the column "DIVIDEND_YIELD" is selected from the DataFrame
df_QQQ. All values in that column are retrieved. The second. A filter is
applied to the data based on the index label ["2002"] in this part of
the code. From 2002 onward, all values are selected. The third point.
Using the filtered data from the previous step, plot(grid=True) creates
a plot. Line graphs are typically used for this plot, where the x-axis
represents the index labels (dates or times) and the y-axis represents
the values in the "DIVIDEND_YIELD" column. The fourth point. This code
adds a grid to the plot, making it easier to read and interpret. Using
the filtered data from the "DIVIDEND_YIELD" column of a DataFrame, the
code creates a line graph with a grid.</p>
</div>
<div class="cell code" data-execution_count="53" data-scrolled="true">
<div class="sourceCode" id="cb91"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>df_QQQ[DIVIDEND_YIELD][<span class="st">&quot;2002&quot;</span>:].describe()</span></code></pre></div>
<div class="output execute_result" data-execution_count="53">
<pre><code>count    6.293000e+03
mean     8.154579e-03
std      5.614934e-03
min     -2.566770e-07
25%      3.239253e-03
50%      9.365185e-03
75%      1.214337e-02
max      2.051265e-02
Name: Dividend Yield, dtype: float64</code></pre>
</div>
</div>
<div id="f7566722" class="cell markdown">
<p>The code below describes and summarizes a column in a DataFrame
called "df_QQQ." The column being analyzed is "DIVIDEND_YIELD." The
first step is to select a subset of the DataFrame, specifically the data
starting in 2002. We are selecting all rows from the year 2002 until the
end of the DataFrame using the slice notation ["2002":]. This subset of
data is then described using the "describe()" function. In the
"describe()" function, you can see the count (number of non-missing
values), the mean, the standard deviation, the minimum value, the 25th
percentile (first quartile), the median (50th percentile), the 75th
percentile (third quartile), and the maximum value for the selected
column. We can get a concise summary of the distribution and central
tendency of dividend yield data starting in 2002 by invoking the
"describe()" function on the subset of data from the "DIVIDEND_YIELD"
column.</p>
</div>
<div class="cell markdown">
<p>Blue dots indicate the actual historical 1-year returns of the NASDAQ
100. A solid black line shows the model's forecasted mean, which is very
poorly matched with historical data.</p>
</div>
<div class="cell code" data-execution_count="54" data-scrolled="true">
<div class="sourceCode" id="cb93"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">1</span>, ticker<span class="op">=</span>ticker_QQQ, df<span class="op">=</span>df_QQQ)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/5f6551bf4c824e5c29907279b027e46925e56cee.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	17.8%		13.0%		7.32e-196
R^2:	-0.60
</code></pre>
</div>
</div>
<div id="8570a3e9" class="cell markdown">
<p>This code snippet, plot_ann_returns(years=1, ticker=ticker_QQQ,
df=df_QQQ), calls a function called plot_ann_returns and passes three
arguments: <code>years</code>, <code>ticker</code>, and <code>df</code>.
A value of 1 indicates that we want to calculate annual returns for a
year. The argument <code>ticker</code> is set to
<code>ticker_QQQ</code>, which likely corresponds to the stock symbol
for the QQQ index. In the above example, the argument represents a
dataframe containing historical price data for the QQQ index.
Plot_ann_returns performs several steps to analyze and visualize annual
returns for a specified stock or index. Based on its syntax, we might
assume that it will first filter the dataframe <code>df</code> to
include data for the desired number of years, in this case, 1 year. By
comparing the initial and final prices, it will calculate the annual
returns for the selected time period. A plot of the annual returns will
then be created by the function. The annual returns might be displayed
as a line graph or a bar graph, depending on the implementation. As the
x-axis represents the years under consideration, the y-axis represents
the corresponding returns. I believe this code snippet is part of a
larger program or script that analyzes and visualizes annual returns for
a specific stock or index over a specified period of time.</p>
</div>
<div class="cell markdown">
<p>This plot shows the historical 3-year returns of the NASDAQ 100,
which fits the forecasting model reasonably well with <span
class="math inline"><em>R</em><sup>2</sup> = 0.41</span> for such short
investment periods.</p>
</div>
<div class="cell code" data-execution_count="55">
<div class="sourceCode" id="cb95"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">3</span>, ticker<span class="op">=</span>ticker_QQQ, df<span class="op">=</span>df_QQQ)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/7e9e91bc5f610279108379d41333e32e2e70c0d7.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	5.2%		7.2%		9.71e-216
R^2:	0.41
</code></pre>
</div>
</div>
<div id="2ebdd47f" class="cell markdown">
<p>Plot_ann_returns(years=3, ticker=ticker_QQQ, df=df_QQQ) plots the
annual returns of a financial instrument, specifically the ticker symbol
"QQQ", over a three-year period. For this code, the input parameters are
3 years, the ticker symbol for the instrument, which is "QQQ" in this
case, and a DataFrame containing the required data points. With this
information, the code will generate a plot that displays the annual
returns for the specified instrument ("QQQ") over the specified period
of time (three years) using the data provided in the DataFrame
("df_QQQ"). Plotting the performance of the instrument over time can be
useful for analyzing its performance visually.</p>
</div>
<div class="cell markdown">
<p>Here is a plot of the NASDAQ 100's historical 5-year returns. It is a
fairly well fitted forecasting model, <span
class="math inline"><em>R</em><sup>2</sup> = 0.69</span>.</p>
</div>
<div class="cell code" data-execution_count="56">
<div class="sourceCode" id="cb97"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">5</span>, ticker<span class="op">=</span>ticker_QQQ, df<span class="op">=</span>df_QQQ)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/ae228eb66b7868f9ab2652e3dab34b77ea85114f.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	3.4%		6.7%		0.00e+00
R^2:	0.69
</code></pre>
</div>
</div>
<div id="93161f00" class="cell markdown">
<p>Plot_ann_returns(years=5, ticker=ticker_QQQ, df=df_QQQ) calls a
function named plot_ann_returns and passes three arguments:
<code>years</code> with a value of 5, <code>ticker</code> with a value
of <code>ticker_QQQ</code>, and <code>df</code> with a value of
<code>df_QQQ</code>. Probably designed to plot the annual returns for a
particular stock or investment represented by the ticker symbol. It uses
the provided dataframe (<code>df_QQQ</code>) which presumably contains
historical data for the given stock. Calculations of the annual returns
are based on the specified number of years (in this case, 5). This code
would output a graphical representation, such as a line or bar chart,
showing the annual returns of the investment over the specified period
of time. On the plot, the x-axis represents years, and the y-axis
represents percentage returns. Visualizing the performance of the
investment over time can be useful for analyzing and understanding
it.</p>
</div>
<div class="cell markdown">
<p>This plot shows the NASDAQ 100 for 10-year investment periods, which
fits the forecasting model very well, with R2 = 0.82, explaining most of
the data's variance.</p>
</div>
<div class="cell code" data-execution_count="57">
<div class="sourceCode" id="cb99"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">10</span>, ticker<span class="op">=</span>ticker_QQQ, df<span class="op">=</span>df_QQQ)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/d2929fa0aa1512a5f88f92597acc1f07162daa5e.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	0.9%		1.8%		2.33e-141
R^2:	0.82
</code></pre>
</div>
</div>
<div id="cc269e52" class="cell markdown">
<p>In the given code, plot_ann_returns is called with three parameters:
years, ticker, and df. The purpose of this function is to plot the
annual returns of a stock over a specified period. In order to plot the
data, the function takes the value of the 'years' parameter. The
'ticker' parameter represents the symbol of the stock ticker. Stock data
for a specific stock can be retrieved using this identifier. The
function takes the value of the 'df' parameter, which represents the
stock data to be plotted. Typically, this data is provided as a pandas
DataFrame, containing historical stock prices. After the necessary
parameters are provided, the function calculates the stock's annual
returns based on the given number of years. First, it selects the
closing prices from the stock data DataFrame. It then calculates the
percentage change in closing prices over the past year. We now have the
annual returns for each year. Lastly, the function generates a plot
displaying the annual returns over the specified number of years using a
library like matplotlib. This plot represents the years by the x-axis,
and the returns by the y-axis. Visually analyzing the stock's
performance over time allows us to identify trends or patterns.</p>
</div>
<div class="cell markdown">
<p>If we consider the mean annualized return over a period of three to
seven years, we can smooth out the effect of stock market bubbles and
crashes. Here's a plot showing a forecasting model with R^2 = 0.71. The
fit is only slightly better than that for fixed 5-year investment
periods, which had R^2 = 0.69.</p>
</div>
<div class="cell code" data-execution_count="58">
<div class="sourceCode" id="cb101"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>plot_ann_returns(years<span class="op">=</span><span class="dv">5</span>, years_range<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>                 ticker<span class="op">=</span>ticker_QQQ, df<span class="op">=</span>df_QQQ)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/858c409af2267cde0596236803679178cd977b0f.png" /></p>
</div>
<div class="output stream stdout">
<pre><code>	Forecast	Baseline	p-value
=================================================
MAE:	3.1%		6.3%		0.00e+00
R^2:	0.71
</code></pre>
</div>
</div>
<div id="496d6f12" class="cell markdown">
<p>It plots the annual returns for a specific stock over a specific
period of time using the code plot_ann_returns(years=5, years_range=2,
ticker=ticker_QQQ, df=df_QQQ). It requires the following inputs: -
<code>years</code> parameter specifying the number of years for which
annual returns need to be calculated. It is set to 5 in this case.
Specify the number of years for each individual return calculation in
the years_range parameter. For this example, it is set to 2, meaning
returns will be calculated for each pair of years. There is one
parameter named ticker, which specifies the ticker symbol for the stock.
Here, it is set to <code>ticker_QQQ</code>. This parameter specifies the
data frame containing historical stock prices. This is set to
<code>df_QQQ</code>. The code will calculate the annual returns for each
pair of two consecutive years over the specified total number of years
based on these inputs. A graph will then be plotted illustrating these
annual returns, with each bar representing a specific pair of years. As
a result of this visualization, we can analyze the stock's performance
and identify any trends or patterns in its annual returns.</p>
</div>
<div class="cell markdown">
<p>The P/S ratios of the stock indices will now be correlated. It tells
us whether stock indices tend to be cheap or expensive at the same time.
In order to construct an investment strategy that switches between these
stock indices, so that it buys the cheap ones and sells the expensive
ones, we need to know this. Unfortunately, these stock indices are
highly correlated, so they are often cheap or expensive at the same
time.</p>
</div>
<div class="cell code" data-execution_count="59">
<div class="sourceCode" id="cb103"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Lists of tickers and data we want to compare.</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>tickers <span class="op">=</span> [ticker_SP500, ticker_SP400, ticker_SP600, ticker_QQQ]</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>dfs <span class="op">=</span> [df_SP500[PSALES], df_SP400[PSALES],</span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>       df_SP600[PSALES], df_QQQ[PSALES]]</span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a single DataFrame with all the P/Sales ratios.</span></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>df_psales <span class="op">=</span> pd.concat(dfs, axis<span class="op">=</span><span class="dv">1</span>).dropna()</span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Rename columns to ticker-symbols.</span></span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a>df_psales.set_axis(tickers, axis<span class="op">=</span><span class="dv">1</span>, inplace<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
</div>
<div id="8d07074a" class="cell markdown">
<p>Price-to-Sales (P/S) ratios of different stocks or indices can be
compared using this code. We want to compare four lists of tickers and
data. This list contains the symbols of the stocks or indices we are
comparing. P/Sales ratios are extracted from dataframes for each ticker
in the dfs list. Concatenating the dataframes in the dfs list along the
columns (axis=1) creates a new dataframe, df_psales. By doing this, all
the P/S ratios for the different tickers are combined into a single
dataframe. As a next step, the columns of the df_psales dataframe are
renamed to reflect the ticker symbols. Assigning the tickers to the new
columns is done using the set_axis method. As the axis parameter is set
to 1, we are renaming the columns, and the inplace parameter is set to
True to modify the df_psales dataframe directly. Essentially, this code
combines P/S ratios for different tickers into a single dataframe, and
then renames the columns to the ticker symbols. P/Sales ratios can be
compared and analyzed across multiple stocks or indices using this
method.</p>
</div>
<div class="cell markdown">
<p>In the following table, we show the correlation between P/Sales
ratios for stock indices. A value of 1 indicates complete positive
correlation, that is, the P/Sales ratios of two indices are always high
or low at the same time, a value of 0 indicates there is no correlation,
and a value of -1 indicates complete negative correlation. There is a
high correlation between these stock indices' P/Sales ratios. With a
correlation coefficient of 0.86, the S&amp;P 500 and S&amp;P 400 almost
always have high or low P/Sales ratios at the same time. Stock indices
S&amp;P 600 and QQQ ETF are the least correlated, with a correlation
coefficient of 0.48, but this is still a significant correlation.</p>
</div>
<div class="cell code" data-execution_count="60">
<div class="sourceCode" id="cb104"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>df_psales.corr()</span></code></pre></div>
<div class="output execute_result" data-execution_count="60">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>S&amp;P 500</th>
      <th>S&amp;P 400</th>
      <th>S&amp;P 600</th>
      <th>QQQ</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>S&amp;P 500</th>
      <td>1.000000</td>
      <td>0.861719</td>
      <td>0.814126</td>
      <td>0.702399</td>
    </tr>
    <tr>
      <th>S&amp;P 400</th>
      <td>0.861719</td>
      <td>1.000000</td>
      <td>0.941318</td>
      <td>0.631153</td>
    </tr>
    <tr>
      <th>S&amp;P 600</th>
      <td>0.814126</td>
      <td>0.941318</td>
      <td>1.000000</td>
      <td>0.483363</td>
    </tr>
    <tr>
      <th>QQQ</th>
      <td>0.702399</td>
      <td>0.631153</td>
      <td>0.483363</td>
      <td>1.000000</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<div id="7c8320d9" class="cell markdown">
<p>In the dataframe "df_psales", "df_psales.corr()" calculates the
correlation between different columns. In the first step, it applies the
"corr()" function to the dataframe "df_psales". "corr()" calculates the
correlation between all pairs of columns in the dataframe. A correlation
indicates whether two variables move together or in opposite directions
based on their relationship. This code will produce a correlation
matrix, which is a square table with each row and column corresponding
to a variable. Table values represent correlation coefficients, which
range from -1 to 1. A correlation coefficient of 1 indicates a perfect
positive correlation, a correlation coefficient of -1 indicates a
perfect negative correlation, and a correlation coefficient of 0
indicates no correlation at all.</p>
</div>
<div class="cell markdown">
<p>A scatterplot of the P/Sales ratios for the S&amp;P 500 and S&amp;P
400 demonstrates the strong correlation.</p>
</div>
<div class="cell code" data-execution_count="61">
<div class="sourceCode" id="cb105"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>df_psales.plot(kind<span class="op">=</span><span class="st">&#39;scatter&#39;</span>, x<span class="op">=</span>ticker_SP500, y<span class="op">=</span>ticker_SP400, grid<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<div class="output execute_result" data-execution_count="61">
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f88606f2c88&gt;</code></pre>
</div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/4511e93936ae3491a3d85537f0be1a41b3100dd3.png" /></p>
</div>
</div>
<div id="8bf8639c" class="cell markdown">
<p>The code plots a scatter plot using data from a dataframe called
'df_psales'. This scatter plot illustrates the relationship between two
variables, where the x-axis represents the values of a variable called
'ticker_SP500' and the y-axis represents the values of a variable called
'ticker_SP400'. 'kind' specifies the type of plot we want to create, in
this case a scatter plot. When the 'grid' parameter is set to 'True',
gridlines are added to the plot, which can make it easier to read the
data. Based on the data in the 'df_psales' dataframe, this code will
generate the scatter plot visualization, which will provide insight into
the relationship between the variables 'ticker_SP500' and
'ticker_SP400'.</p>
</div>
<div class="cell markdown">
<p>In the following scatter-plot, we compare the P/Sales ratios of the
S&amp;P 600 with the QQQ ETF. At times of market crashes, both indices
are cheap due to low P/S ratios. For higher P/Sales ratios, the
correlation is weaker. The correlation coefficient overall is 0.48.</p>
</div>
<div class="cell code" data-execution_count="62">
<div class="sourceCode" id="cb107"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>df_psales.plot(kind<span class="op">=</span><span class="st">&#39;scatter&#39;</span>, x<span class="op">=</span>ticker_QQQ, y<span class="op">=</span>ticker_SP600, grid<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<div class="output execute_result" data-execution_count="62">
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f8860785128&gt;</code></pre>
</div>
<div class="output display_data">
<p><img
src="vertopal_0132d21254b04430b520998d95257dd9/fad2ea5e8a3ab860110544f13d9288ae2815be72.png" /></p>
</div>
</div>
<div id="39add476" class="cell markdown">
<p>The following code creates a scatter plot using data from two columns
in a DataFrame, <code>df_psales</code>. A scatter plot shows the
relationship between two variables. In this case, the x-axis variable is
ticker_QQQ, and the y-axis variable is ticker_SP600. It is likely that
these variables are columns in the DataFrame <code>df_psales</code>.
With kind='scatter', the plotting function is instructed to create
scatter plots. This parameter adds a grid to the plot. In the scatter
plot, each point represents a combination of values from the columns
ticker_QQQ and ticker_SP600. This scatter plot helps visualize the
relationship, if any, between these two variables.</p>
</div>
<div class="cell markdown">
<p>Certainly! Here's a quick explanation of the forecasting formulas: We
use the following formulas to forecast mean annualized returns and
standard deviations: Mean Annualized Return: In order to calculate a
mean annualized return, a parameter called "a" is multiplied by the
current P/Sales ratio multiplied by the inverse of the investment
period. The estimated mean annualized return is obtained by subtracting
1 from this result.</p>
<p>Standard Deviation of Annualized Return: A standard deviation of
annualized returns is calculated by dividing the current P/Sales ratio
by the inverse of the investment period. With the appropriate values for
"a" and "b" and the current P/Sales ratio, we can calculate the mean
annualized return and its standard deviation. Based on historical data
and the current P/S ratio, these formulas provide insight into the
expected returns and level of uncertainty associated with an
investment.</p>
</div>
<div class="cell markdown">
<p>Forecasting formulas require the current P/S ratio to be input. Here
are the P/S ratios as of April 9, 2019, along with links to
Morningstar's current data for corresponding ETFs. The P/S ratios
mentioned on Morningstar are described as "forward-looking based on
historical data." It is unclear what this means. The P/Sales ratios are
not specified whether they are updated daily or monthly. Therefore,
these ratios should be considered estimates and may fluctuate.</p>
</div>
<div class="cell markdown">
<p>Table 1 summarizes the parameters <span
class="math inline"><em>a</em></span> and $b" that are used in
forecasting formulas for 3-7 year returns. It also includes the <span
class="math inline"><em>R</em><sup>2</sup></span> values, which indicate
how well the historical data fits the forecasting model. In order to
illustrate the use of the forecasting formula, let's look at the NASDAQ
index (QQQ). Using the given parameters <span
class="math inline"><em>a</em></span> and <span
class="math inline"><em>b</em></span>, along with the P/Sales ratio of
3.27 from early April 2019, we can calculate the expected annualized
return and standard deviation as follows:</p>
<p>The annualized return is calculated as follows: <span
class="math inline">$\frac{a}{P/Sales_t ^ {1/Years}} - 1$</span>. By
plugging in the values, we get: <span
class="math inline">$\frac{1.38}{3.27 ^ {1/5}} - 1 \simeq 8.9\%$</span>.
The standard deviation is calculated using the formula: <span
class="math inline">$\frac{b}{P/Sales_t ^ 1/1 Year]$</span>. By
substituting the values, we get: <span
class="math inline">$\frac{0.066}{3.27 ^ {1/5}} \simeq 5.2\%$</span>.
For investment periods of 3-7 years, the NASDAQ index (QQQ) should have
an annualized return of 8.9% with a standard deviation of 5.2%. For the
3-7 year periods, the forecasting model assumes an average period length
of 5 years. Using the P/S ratios from early April 2019, the following
table presents the forecasted annualized returns for all stock indices.
P/Sales ratios, forecasted return means, and forecasted return standard
deviations are included. The S&amp;P 500 is forecast to lose -2.2%
annually, while the other indices will gain around 9%. With a standard
deviation of 4.4%, the S&amp;P 400 has the lowest level of uncertainty,
while the NASDAQ (QQQ) has the highest. In the S&amp;P 500, a
revaluation process is primarily responsible for the forecasted loss of
2.2%. The current P/S ratio is 1.97, which is significantly higher than
the historical average of 1.36. The discrepancy indicates an expected
revaluation loss of approximately -30%, or around -7.1% on an annualized
basis. While the assumed sales growth matches the historical average of
3.7% per year, and the dividend yield contributes another 2.1% per year,
these gains are insufficient to offset the revaluation loss. The
forecasting model does not simply add up these components, so the
forecasted loss of -2.2% does not add up. NASDAQ's current P/Sales ratio
of 3.27 is about 15% higher than its historical average of 2.86. Due to
the revaluation of the P/Sales ratio, the forecasting model predicts an
annualized loss of approximately -2.6%. Accordingly, the expected sales
growth is assumed to be 11.4%, which is about 3 percentage points higher
than for the S&amp;P 400 and 600. The forecasted return of 8.9% for
NASDAQ includes a slight loss from revaluation, a substantial gain from
sales growth, and a dividend gain of less than 1%. Meanwhile, the
S&amp;P 400 and 600 are trading near their historical average P/S
ratios. Therefore, their future returns are expected to largely be
driven by sales growth of 8-9% and dividend yields of approximately
1%.</p>
</div>
<div class="cell markdown">
<p>A forecasting model for 10-year investment periods is shown in the
table below. Furthermore, it displays the <span
class="math inline"><em>R</em><sup>2</sup></span> values, which indicate
how well the model fits the historical data. In this case, the
forecasting model does not fit the historical data well for the S&amp;P
400 and 600 indices, as indicated by the negative <span
class="math inline"><em>R</em><sup>2</sup></span> values. However, we
will still attempt to calculate their forecasted returns based on these
parameters. The table shows how the forecasted return for the NASDAQ
index can be calculated over the 10-year period between April 2019 and
2029. For April 2019, the P/Sales ratio was 3.27, which incorporates the
parameters <span class="math inline"><em>a</em></span> and <span
class="math inline"><em>b</em></span> from the table. This formula
predicts a mean return of 11.0% per year, with a standard deviation of
3.1%. The following table shows the forecasted returns for all four
stock indices over a 10-year period. The P/S ratios for April 2019, the
forecasted return mean, and the forecasted return standard deviation are
provided. With a forecasted return of 1.8% per year, the S&amp;P 500 is
expected to have the lowest return, while the NASDAQ 100 is expected to
have the highest. Although the forecasted mean for NASDAQ is
significantly higher than that for S&amp;P 500, the standard deviation
for the NASDAQ 100 (3.1%) is slightly lower than that of S&amp;P 500
(3.6%). Instead of measuring investment risk, the standard deviation
measures the spread of possible outcomes and the degree of uncertainty
around the mean forecast. A future revaluation is assumed to result in a
loss for the S&amp;P 500, because it trades at a higher P/Sales ratio
than its historical average at the moment. In the event that the P/Sales
ratio reverts to its historical average, the model predicts a loss of
approximately -31%. The loss is spread over 10 years, resulting in a
loss of -3.6% per year. Additionally, the model assumes that historical
average sales growth and dividend yield will continue, contributing
gains of 3.7% and 2.1%, respectively. Due to the complexity of the
forecasting formula, these components do not simply add up to the
forecasted return of 1.8%. Although the historical data for the S&amp;P
400 and 600 indices does not fit well with the forecasted returns, it
may still be useful to consider their forecasts as rough estimates since
a better model is not available. S&amp;P 400 is forecasted to return
9.5% per year, while S&amp;P 600 is forecasted to return 9.0% per year.
Forecasted returns for the NASDAQ 100 are 11.0%. According to these
forecasts, future sales growth, dividend yield, and P/S ratios will be
similar to historical averages.</p>
</div>
<div class="cell markdown">
<p>We use the P/Sales ratio instead of the P/E ratio because it is more
stable. P/S ratio is calculated by dividing Price Per Share by Sales Per
Share. Shares are compared to their past 12 months' sales per share to
determine how cheap or expensive they are. P/S ratios are difficult to
interpret and compare since a "fair" P/S ratio differs from company to
company. Divide the price per share by the earnings per share to get the
P/E ratio. It is easier to interpret, especially if we consider the
reciprocal Earnings Yield, since that can be compared among companies
and even with bond yields. Earnings Per Share may fluctuate greatly and
even be zero or even negative, meaning that the P/E ratio is no longer
reliable. In forecasting formulas, this creates more noise and makes it
difficult to use the current P/E ratio as a predictor variable.</p>
<p>With these forecasting formulas, we can easily adjust the assumptions
as needed. By scaling <span class="math inline"><em>a</em></span> by
1.02, for example, if we believe future sales will be 2% higher than the
historical average, we can adjust <span
class="math inline"><em>a</em></span> accordingly. It is possible,
however, that a significant portion of the forecasted return is due to a
revaluation of the P/S ratio. Consequently, if the future P/S ratios
differ from the historical data, then the parameter <span
class="math inline"><em>a</em></span> needs to be adjusted. It is
currently unclear what defines a "fair" P/S ratio, so changing it from
its past would only be a guess. There is a need for more research to
understand how P/S ratios are typically related to, for example, sales
growth and profit margins.</p>
<p>It would be possible to develop a simple strategy that invests in
ETFs according to the forecasted returns of different stock-market
indices. This requires two things: First, we must estimate the future
means of dividend yield, sales growth, and P/S ratios in order to use
the forecasting model to estimate future returns. Assume the future
means will be roughly similar to the historical data as a simple
solution. For broadly diversified stock indices, this assumption may be
reasonable. 2) In order for the strategy to work, the indices must be
low or inversely correlated so that the investment portfolio can be
switched between them. Due to their high correlation, these four indices
are usually cheap or expensive at the same time, so the strategy cannot
switch between them by selling an expensive index and buying a cheap
index. To make this work, stock indices must have a low or negative
correlation.</p>
</div>
<div class="cell markdown">
<p>In this paper, we applied our method for long-term stock forecasting
to four stock indices in the USA: the S&amp;P 500 (Large-Cap), the
S&amp;P 400 (Mid-Cap), the S&amp;P 600 (Small-Cap), and the NASDAQ-100
(mainly technology). With a few exceptions, the forecasting model
performed well on the historical data. Our ability to accurately
estimate future dividend yields, sales growth, and P/S ratios for stock
indices will determine whether it works in the future. As a result of
the broad diversification of these stock indices, and the cyclical and
mean-reverting nature of the historical data, it seems reasonable to
assume that the historical averages will hold true in the future. These
formulas can be used to estimate the long-term returns of these four
stock indices.</p>
</div>
<div class="cell markdown">
<p>Further research on this topic is highly recommended. Please let me
know if you find any new findings. In my knowledge, no academic study
has predicted the long-term returns of stocks and stock markets as we
have. Research in this area still needs to be done, and it has the
potential to have a significant impact on both theoretical and applied
finance. Here are some additional research ideas to help you get
started: Check the mathematical calculations and Python implementation
of the forecasting model for mistakes. The forecasting model can be used
with data from other stock indices if you have access to it. Can it make
accurate predictions? What could be the reasons if not? Investigate why
the forecasting model fails to predict 10-year returns for the S&amp;P
400 and 600, but does better for 3-7-year returns. What is the most
accurate way to estimate future mean dividend yields, sales growth, and
P/S ratios? Examine how different stocks and indices determine the P/S
ratio. Does it depend on factors like profit margins and sales growth?
If you had access to more low-correlation stock indices, how would you
approach portfolio optimization?</p>
</div>
</body>
</html>
