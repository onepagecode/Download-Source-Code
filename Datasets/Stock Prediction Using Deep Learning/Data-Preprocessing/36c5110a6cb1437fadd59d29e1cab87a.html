<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>03a5d0670e6d45d49891a3be2616f82c</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="cell code" data-execution_count="2" id="UParaEW2yZ7O">
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span></code></pre></div>
</div>
<div class="cell markdown">
<p>It imports the necessary libraries for data analysis and
visualization: <code>numpy</code>, <code>pandas</code>,
<code>matplotlib.pyplot</code>, and <code>seaborn</code>. These
libraries provide various functions and tools for working with data and
creating plots.</p>
<p>By importing <code>numpy</code> as <code>np</code>, it allows you to
use the functions and data structures provided by the <code>numpy</code>
library using the <code>np</code> prefix. Similarly, <code>pandas</code>
is imported as <code>pd</code>, which allows you to access
<code>pandas</code> functions and data structures using the
<code>pd</code> prefix.</p>
<p><code>matplotlib.pyplot</code> is imported as <code>plt</code>, which
is a submodule of the <code>matplotlib</code> library. It provides a
convenient interface for creating and customizing plots. Seaborn is
imported as sns, which is a Matplotlib-based data visualization library.
It provides additional functionality and aesthetic enhancements for
creating appealing statistical graphics. In general, it prepares the
environment for data analysis and visualization. Imported libraries can
be used to manipulate data, perform calculations, and create
visualizations.</p>
</div>
<div class="cell markdown" id="3Rr1pxEPYSdU">
<p>Loading of data</p>
</div>
<div class="cell code" data-execution_count="3" id="n5AreMqlzaXd">
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>AAPL <span class="op">=</span> pd.read_csv(<span class="st">&quot;/content/drive/MyDrive/Database/AAPL.csv&quot;</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>TSLA <span class="op">=</span> pd.read_csv(<span class="st">&quot;/content/drive/MyDrive/Database/TSLA.csv&quot;</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>GOOG <span class="op">=</span> pd.read_csv(<span class="st">&quot;/content/drive/MyDrive/Database/GOOG.csv&quot;</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>MSFT <span class="op">=</span> pd.read_csv(<span class="st">&quot;/content/drive/MyDrive/Database/MSFT.csv&quot;</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>AMZN <span class="op">=</span> pd.read_csv(<span class="st">&quot;/content/drive/MyDrive/Database/AMZN.csv&quot;</span>)</span></code></pre></div>
</div>
<div class="cell markdown">
<p>Data is read from five separate CSV files: "AAPL.csv", "TSLA.csv",
"GOOG.csv", "MSFT.csv", and "AMZN.csv". Each file contains data related
to a specific company's stock market information. CSV files are read
with pandas's read_csv() function. It takes the file paths as input and
returns a pandas DataFrame object, which is a tabular data structure
that can store and manipulate data.</p>
<p>By assigning the result of each <code>pd.read_csv()</code> call to a
variable (<code>AAPL</code>, <code>TSLA</code>, <code>GOOG</code>,
<code>MSFT</code>, <code>AMZN</code>), the code creates separate
DataFrames for each company's data. Access and analysis of the data
contained in the respective CSV files can be done using these
DataFrames.</p>
<p>In summary, this code loads data from the CSV files of five different
companies (Apple, Tesla, Google, Microsoft, and Amazon) and stores each
dataset in a separate DataFrame, enabling further analysis and
manipulation of the data.</p>
</div>
<div class="cell markdown" id="wPovSDOEVf_o">
<p>Apfel</p>
</div>
<div class="cell code" data-execution_count="4"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:195}"
id="67FGAZtuz4XH" data-outputId="a4f30f61-8146-4335-addb-5134ed628916">
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>AAPL.head()</span></code></pre></div>
<div class="output execute_result" data-execution_count="4">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Date</th>
      <th>Open</th>
      <th>High</th>
      <th>Low</th>
      <th>Close</th>
      <th>Adj. Close</th>
      <th>Volume</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>26-Feb-2021</td>
      <td>122.59</td>
      <td>124.85</td>
      <td>121.20</td>
      <td>121.26</td>
      <td>121.26</td>
      <td>16,43,20,000</td>
    </tr>
    <tr>
      <th>1</th>
      <td>25-Feb-2021</td>
      <td>124.68</td>
      <td>126.46</td>
      <td>120.54</td>
      <td>120.99</td>
      <td>120.99</td>
      <td>14,73,06,500</td>
    </tr>
    <tr>
      <th>2</th>
      <td>24-Feb-2021</td>
      <td>124.94</td>
      <td>125.56</td>
      <td>122.23</td>
      <td>125.35</td>
      <td>125.35</td>
      <td>11,06,91,500</td>
    </tr>
    <tr>
      <th>3</th>
      <td>23-Feb-2021</td>
      <td>123.76</td>
      <td>126.71</td>
      <td>118.39</td>
      <td>125.86</td>
      <td>125.86</td>
      <td>15,78,59,100</td>
    </tr>
    <tr>
      <th>4</th>
      <td>22-Feb-2021</td>
      <td>128.01</td>
      <td>129.72</td>
      <td>125.60</td>
      <td>126.00</td>
      <td>126.00</td>
      <td>10,36,07,600</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<div class="cell markdown">
<p>It calls the <code>head()</code> function on the DataFrame
<code>AAPL</code>. The <code>head()</code> function is a method provided
by the pandas library and it returns the first few rows of the
DataFrame. AAPL.head() shows a preview of the data stored in the
DataFrame. The default behavior of <code>head()</code> is to return the
first five rows of the DataFrame, providing a glimpse into the structure
and contents of the data.</p>
<p>The purpose of calling <code>head()</code> is to quickly inspect the
initial rows of the DataFrame and get a sense of the data's format,
column names, and values. This can help in understanding the dataset and
making decisions on how to further process, analyze, or visualize the
data. Simply put, AAPL.head() displays a preview of the first few rows
of the AAPL DataFrame.</p>
</div>
<div class="cell code" data-execution_count="5"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}"
id="cGzCr4wqz7aN" data-outputId="d36f447a-bfab-4d6e-83ad-2ad93a30c2d3">
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>AAPL.info()</span></code></pre></div>
<div class="output stream stdout">
<pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
RangeIndex: 9800 entries, 0 to 9799
Data columns (total 7 columns):
 #   Column      Non-Null Count  Dtype  
---  ------      --------------  -----  
 0   Date        9800 non-null   object 
 1   Open        9800 non-null   object 
 2   High        9725 non-null   float64
 3   Low         9725 non-null   float64
 4   Close       9725 non-null   float64
 5   Adj. Close  9725 non-null   float64
 6   Volume      9725 non-null   object 
dtypes: float64(4), object(3)
memory usage: 536.1+ KB
</code></pre>
</div>
</div>
<div class="cell markdown">
<p>An info() function is called on the DataFrame AAPL. The
<code>info()</code> function is a method provided by the pandas library
and it provides information about the DataFrame's structure and content.
When executed, it displays a summary of the DataFrame. This summary
includes details such as the number of rows and columns, the data types
of each column, and the amount of memory used by the DataFrame. This
function provides information about the dataset. It helps in
understanding the data types of each column (e.g., numeric, string,
datetime), identifying any missing values, and estimating the memory
usage. Using info() can help you explore and clean your data. It allows
you to assess the data's integrity, identify potential issues, and make
informed decisions on how to handle and analyze the dataset.</p>
<p>In summary, <code>AAPL.info()</code> provides a concise summary of
the DataFrame <code>AAPL</code>, including information about its
structure, column data types, and memory usage, which assists in
understanding and preparing the dataset for further analysis.</p>
</div>
<div class="cell code" data-execution_count="6" id="fWZV37Sf1dNI">
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop NULL rows</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>AAPL.dropna(inplace <span class="op">=</span> <span class="va">True</span>)</span></code></pre></div>
</div>
<div class="cell markdown">
<p>This code performs a data operation on the DataFrame
<code>AAPL</code> to remove any rows that contain missing or null
values. The <code>dropna()</code> function is a method provided by the
pandas library for handling missing data.</p>
<p>By executing <code>AAPL.dropna(inplace=True)</code>, the code
modifies the DataFrame <code>AAPL</code> in-place by removing any rows
that have null values. The <code>inplace=True</code> parameter ensures
that the changes are applied directly to the DataFrame without creating
a new copy. Dropping null rows cleans up the data and removes incomplete
or unreliable observations. There are many reasons why null values can
occur, such as missing data during data collection or processing errors.
Removing these rows helps to ensure the quality and consistency of the
remaining data. When performing statistical calculations, machine
learning algorithms, or generating visualizations, null rows should be
removed. It ensures that the data being analyzed or visualized is
complete and does not introduce bias or inaccuracies.</p>
<p>In summary, <code>AAPL.dropna(inplace=True)</code> eliminates rows
with null values from the DataFrame <code>AAPL</code>, improving the
data's integrity and preparing it for subsequent analysis or
visualization.</p>
</div>
<div class="cell code" data-execution_count="7" id="vjqd4Iwv0Pd_">
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Change Dtype of Columns</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>AAPL[<span class="st">&quot;Date&quot;</span>] <span class="op">=</span> pd.to_datetime(AAPL[<span class="st">&quot;Date&quot;</span>])</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>AAPL[<span class="st">&quot;Volume&quot;</span>] <span class="op">=</span> AAPL[<span class="st">&quot;Volume&quot;</span>].<span class="bu">str</span>.replace(<span class="st">&#39;,&#39;</span>, <span class="st">&#39;&#39;</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>AAPL <span class="op">=</span> AAPL.astype({<span class="st">&quot;Open&quot;</span>: <span class="bu">float</span>, <span class="st">&quot;Volume&quot;</span>: <span class="bu">float</span>})</span></code></pre></div>
</div>
<div class="cell markdown">
<p>Several operations are performed in this code to modify the data
types of specific columns in the DataFrame <code>AAPL</code>. It
utilizes various methods and functions provided by the pandas library.
Parameters such as "pd.to_datetime(AAPL["Date"])" are used to convert
the "Date" column of the DataFrame AAPL into datetime. This
transformation allows for easier manipulation and analysis of dates and
time-related data. AAPL["Volume"].str.replace() modifies the "Volume"
column in the DataFrame AAPL. In the "Volume" column, commas are
replaced with empty strings. This step is commonly used when dealing
with numeric columns that contain comma separators. This alters the
column data type of the "Open" and "Volume" columns in the DataFrame
<code>AAPL</code> to floating-point numbers (float). The
<code>astype()</code> function is used to explicitly specify the desired
data types for specific columns.</p>
<p>By changing the data types of the columns, the code ensures that the
columns are stored and processed as the appropriate data types,
facilitating calculations, aggregations, and other data operations.</p>
<p>In summary, the code modifies the data types of certain columns in
the DataFrame <code>AAPL</code>. The "Date" column is converted to
datetime format, the "Volume" column is comma-free, and the "Open" and
"Volume" columns are converted to float data types. As a result of these
modifications, data manipulation and analysis are more efficient.</p>
</div>
<div class="cell code" data-execution_count="8" id="nIW5x9nqk0_U">
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Sort the Database by Date</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>AAPL <span class="op">=</span> AAPL.sort_values(by <span class="op">=</span> <span class="st">&#39;Date&#39;</span>, ignore_index <span class="op">=</span> <span class="va">True</span>)</span></code></pre></div>
</div>
<div class="cell markdown">
<p>This code sorts the DataFrame <code>AAPL</code> based on the values
in the "Date" column. It utilizes the <code>sort_values()</code>
function provided by the pandas library.</p>
<p>By executing
<code>AAPL.sort_values(by='Date', ignore_index=True)</code>, the code
rearranges the rows of the DataFrame <code>AAPL</code> so that they are
sorted in ascending order based on the values in the "Date" column.</p>
<p>The <code>by='Date'</code> parameter specifies that the sorting
should be done based on the values in the "Date" column. The
<code>ignore_index=True</code> parameter ensures that the resulting
DataFrame has a new index assigned to the sorted rows, ignoring the
original index values. Various scenarios can be solved by sorting a
database by date. It allows for chronological analysis of the data, such
as tracking changes over time, identifying trends, or comparing
observations at different points in time.</p>
<p>After sorting, the DataFrame <code>AAPL</code> will have its rows
reordered based on the ascending order of the dates in the "Date"
column. This new order of rows can provide a clearer temporal
perspective on the dataset and facilitate subsequent analyses or
visualizations.</p>
<p>In summary,
<code>AAPL = AAPL.sort_values(by='Date', ignore_index=True)</code> sorts
the DataFrame <code>AAPL</code> in ascending order based on the values
in the "Date" column, resulting in a rearranged DataFrame that is
ordered chronologically.</p>
</div>
<div class="cell code" data-execution_count="9" id="Ak7JL6j4Assr">
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop rows having Date &lt; &#39;2015-01-01&#39;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>AAPL <span class="op">=</span> AAPL[AAPL[<span class="st">&quot;Date&quot;</span>] <span class="op">&gt;=</span> <span class="st">&#39;2015-01-01&#39;</span>].reset_index(drop <span class="op">=</span> <span class="va">True</span>)</span></code></pre></div>
</div>
<div class="cell markdown">
<p>This code removes rows from the DataFrame <code>AAPL</code> that have
a date earlier than January 1, 2015. Using the pandas library, the
application uses conditional indexing and DataFrame manipulation
techniques. In the example below, the code creates a new DataFrame
containing only rows with values greater than or equal to '2015-01-01'
in the "Date" column. In other words, it filters out the rows that have
dates before January 1, 2015. The resulting DataFrame will only contain
rows that meet the specified condition. This can be useful when focusing
on a specific time period or when excluding outdated data from the
analysis. In this code, the index of the DataFrame is reset after
filtering. The <code>drop=True</code> parameter ensures that the old
index is not added as a new column in the DataFrame.
//[AAPL]=AAPL[AAPL["Date"] &gt; '2015-01-01'].reset_index(drop=True), as
above. Filtering narrows down the dataset so that it can be analyzed or
visualized based on a specific time range.</p>
</div>
<div class="cell code" data-execution_count="10"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:284}"
id="xi4cQyhi0Acu" data-outputId="5494cba5-8cfb-48e2-8724-2b4003a90028">
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>AAPL.describe()</span></code></pre></div>
<div class="output execute_result" data-execution_count="10">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Open</th>
      <th>High</th>
      <th>Low</th>
      <th>Close</th>
      <th>Adj. Close</th>
      <th>Volume</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>1549.000000</td>
      <td>1549.000000</td>
      <td>1549.000000</td>
      <td>1549.000000</td>
      <td>1549.000000</td>
      <td>1.549000e+03</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>50.160265</td>
      <td>50.700723</td>
      <td>49.618696</td>
      <td>50.182447</td>
      <td>48.781143</td>
      <td>1.449887e+08</td>
    </tr>
    <tr>
      <th>std</th>
      <td>28.029971</td>
      <td>28.433917</td>
      <td>27.552589</td>
      <td>28.007536</td>
      <td>28.560715</td>
      <td>7.095025e+07</td>
    </tr>
    <tr>
      <th>min</th>
      <td>22.500000</td>
      <td>22.920000</td>
      <td>22.370000</td>
      <td>22.580000</td>
      <td>21.130000</td>
      <td>4.544800e+07</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>30.000000</td>
      <td>30.130000</td>
      <td>29.810000</td>
      <td>29.990000</td>
      <td>27.910000</td>
      <td>9.667000e+07</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>42.020000</td>
      <td>42.550000</td>
      <td>41.630000</td>
      <td>42.100000</td>
      <td>40.600000</td>
      <td>1.272076e+08</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>55.100000</td>
      <td>55.710000</td>
      <td>54.370000</td>
      <td>55.170000</td>
      <td>53.980000</td>
      <td>1.731832e+08</td>
    </tr>
    <tr>
      <th>max</th>
      <td>143.600000</td>
      <td>145.090000</td>
      <td>141.370000</td>
      <td>143.160000</td>
      <td>142.950000</td>
      <td>6.488252e+08</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<div class="cell markdown">
<p>This code computes descriptive statistics for the DataFrame
<code>AAPL</code> using the <code>describe()</code> function provided by
the pandas library. For each numerical column in the DataFrame, the code
outputs a summary of statistical measures. It provides information such
as the count (number of non-null values), mean, standard deviation,
minimum value, quartiles (25th, 50th, and 75th percentiles), and maximum
value.</p>
<p>The <code>describe()</code> function helps in gaining a high-level
understanding of the numerical data in the DataFrame. The value
distribution and central tendency of each column can be analyzed by it.
It is possible to identify outliers, determine the range of values,
identify potential issues with the data (e.g., exceptionally high or low
values), and make initial assessments about how distributed the data is.
It computes and displays summary statistics for the numerical columns in
the DataFrame <code>AAPL</code>. Statistical measures provide insight
into the distribution and characteristics of data.</p>
</div>
<div class="cell markdown" id="8kogTb1BVp-s">
<p>Electra</p>
</div>
<div class="cell code" data-execution_count="11"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:195}"
id="rsMsnDBR0K74" data-outputId="a6613b83-2d1d-4559-f5a5-6422867fd912">
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>TSLA.head()</span></code></pre></div>
<div class="output execute_result" data-execution_count="11">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Date</th>
      <th>Open</th>
      <th>High</th>
      <th>Low</th>
      <th>Close</th>
      <th>Adj. Close</th>
      <th>Volume</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>26-Feb-2021</td>
      <td>700.00</td>
      <td>706.70</td>
      <td>659.51</td>
      <td>675.50</td>
      <td>675.50</td>
      <td>4,10,11,300</td>
    </tr>
    <tr>
      <th>1</th>
      <td>25-Feb-2021</td>
      <td>726.15</td>
      <td>737.21</td>
      <td>670.58</td>
      <td>682.22</td>
      <td>682.22</td>
      <td>3,86,19,900</td>
    </tr>
    <tr>
      <th>2</th>
      <td>24-Feb-2021</td>
      <td>711.85</td>
      <td>745.00</td>
      <td>694.17</td>
      <td>742.02</td>
      <td>742.02</td>
      <td>3,66,77,100</td>
    </tr>
    <tr>
      <th>3</th>
      <td>23-Feb-2021</td>
      <td>662.13</td>
      <td>713.61</td>
      <td>619.00</td>
      <td>698.84</td>
      <td>698.84</td>
      <td>6,63,97,000</td>
    </tr>
    <tr>
      <th>4</th>
      <td>22-Feb-2021</td>
      <td>762.64</td>
      <td>768.50</td>
      <td>710.20</td>
      <td>714.50</td>
      <td>714.50</td>
      <td>3,70,11,700</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<div class="cell markdown">
<p>The code calls the head() function on the DataFrame
<code>TSLA</code>. The <code>head()</code> function is a method provided
by the pandas library and it returns the first few rows of the
DataFrame. The function displays a preview of the data in the DataFrame.
The default behavior of <code>head()</code> is to return the first five
rows of the DataFrame, providing a glimpse into the structure and
contents of the data.</p>
<p>The purpose of calling <code>head()</code> is to quickly inspect the
initial rows of the DataFrame and get a sense of the data's format,
column names, and values. This can help in understanding the dataset and
making decisions on how to further process, analyze, or visualize the
data.</p>
<p>In summary, <code>TSLA.head()</code> outputs a preview of the first
few rows of the DataFrame <code>TSLA</code>, allowing for a quick
examination of the data.</p>
</div>
<div class="cell code" data-execution_count="12"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}"
id="jwT_7xZL4Czb" data-outputId="6de8bc42-9184-4874-d0be-a5707a96a076">
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>TSLA.info()</span></code></pre></div>
<div class="output stream stdout">
<pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
RangeIndex: 2686 entries, 0 to 2685
Data columns (total 7 columns):
 #   Column      Non-Null Count  Dtype  
---  ------      --------------  -----  
 0   Date        2686 non-null   object 
 1   Open        2686 non-null   object 
 2   High        2685 non-null   float64
 3   Low         2685 non-null   float64
 4   Close       2685 non-null   float64
 5   Adj. Close  2685 non-null   float64
 6   Volume      2685 non-null   object 
dtypes: float64(4), object(3)
memory usage: 147.0+ KB
</code></pre>
</div>
</div>
<div class="cell markdown">
<p>The dataframe TSLA is called with the info() function. The
<code>info()</code> function is a method provided by the pandas library,
and it provides information about the DataFrame's structure and content.
TSLA.info() displays the summary of TSLA. This summary includes details
such as the number of rows and columns, the data types of each column,
and the amount of memory used by the DataFrame. This function is used to
get a summary of the dataset. It helps in understanding the data types
of each column (e.g., numeric, string, datetime), identifying any
missing values, and estimating the memory usage. It is useful for data
exploration, data cleaning, and memory optimization. It allows you to
assess the data's integrity, identify potential issues, and make
informed decisions on how to handle and analyze the dataset.</p>
<p>In summary, <code>TSLA.info()</code> provides a concise summary of
the DataFrame <code>TSLA</code>, including information about its
structure, column data types, and memory usage. The purpose of this
summary is to assist in understanding and preparing the dataset for
further analysis.</p>
</div>
<div class="cell code" data-execution_count="13" id="4dDxwLbI4FEA">
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop NULL rows</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>TSLA.dropna(inplace <span class="op">=</span> <span class="va">True</span>)</span></code></pre></div>
</div>
<div class="cell markdown">
<p>The code removes all rows with missing or null values from the
DataFrame <code>TSLA</code>. It uses the <code>dropna()</code> function
provided by the pandas library to handle missing data. When the function
is executed, the rows with null values are dropped from the DataFrame
TSLA. The <code>inplace=True</code> parameter ensures that the changes
are applied directly to the DataFrame without creating a new copy.
Dropping null rows cleans the data and removes unreliable observations.
Data collection errors or missing data can result in null values.
Removing these rows helps to ensure the quality and consistency of the
remaining data. Before performing statistical calculations, machine
learning algorithms, or generating visualizations, null rows should
often be removed. It ensures that the data being analyzed or visualized
is complete and does not introduce bias or inaccuracies.</p>
<p>In summary, <code>TSLA.dropna(inplace=True)</code> removes rows with
null values from the DataFrame <code>TSLA</code>, improving the data's
integrity and preparing it for subsequent analysis or visualization.</p>
</div>
<div class="cell code" data-execution_count="14" id="FlU7Ghku4Jfi">
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Change Dtype of Columns</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>TSLA[<span class="st">&quot;Date&quot;</span>] <span class="op">=</span> pd.to_datetime(TSLA[<span class="st">&quot;Date&quot;</span>])</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>TSLA[<span class="st">&quot;Volume&quot;</span>] <span class="op">=</span> TSLA[<span class="st">&quot;Volume&quot;</span>].<span class="bu">str</span>.replace(<span class="st">&#39;,&#39;</span>, <span class="st">&#39;&#39;</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>TSLA <span class="op">=</span> TSLA.astype({<span class="st">&quot;Open&quot;</span>: <span class="bu">float</span>, <span class="st">&quot;Volume&quot;</span>: <span class="bu">float</span>})</span></code></pre></div>
</div>
<div class="cell markdown">
<p>The code in this section changes the data types of specific columns
in the DataFrame <code>TSLA</code>. It uses methods and functions
provided by the pandas library. PDB.to_datetime(TSLA["Date"]) converts
the "Date" column of TSLA into a datetime. This transformation allows
for easier manipulation and analysis of dates and time-related data. In
the second operation, the "Volume" column is modified in the DataFrame
<code>TSLA</code>. An empty string is substituted for any commas within
the "Volume" column. This step is commonly used when dealing with
numeric columns that contain comma separators. The last step changes the
data type of the "Open" and "Volume" columns in the DataFrame
<code>TSLA</code> to floating-point numbers (float). The
<code>astype()</code> function is used to explicitly specify the desired
data types for specific columns.</p>
<p>By changing the data types of the columns, the code ensures that the
columns are stored and processed as the appropriate data types,
facilitating calculations, aggregations, and other data operations.</p>
<p>In summary, the code modifies the data types of certain columns in
the DataFrame <code>TSLA</code>. Among other things, it converts the
"Date" column to datetime format, removes commas from the "Volume"
column, and converts the "Open" and "Volume" columns to floats. As a
result of these modifications, data manipulation and analysis are more
efficient.</p>
</div>
<div class="cell code" data-execution_count="15" id="CJ2UPRKnmD77">
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Sort the Database by Date</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>TSLA <span class="op">=</span> TSLA.sort_values(by <span class="op">=</span> <span class="st">&#39;Date&#39;</span>, ignore_index <span class="op">=</span> <span class="va">True</span>)</span></code></pre></div>
</div>
<div class="cell markdown">
<p>It sorts the DataFrame TSLA by the values found in the column "Date".
It uses the <code>sort_values()</code> function provided by the pandas
library.</p>
<p>By executing
<code>TSLA.sort_values(by='Date', ignore_index=True)</code>, the code
rearranges the rows of the DataFrame <code>TSLA</code> so that they are
sorted in ascending order based on the values in the "Date" column.</p>
<p>The <code>by='Date'</code> parameter specifies that the sorting
should be done based on the values in the "Date" column. The
<code>ignore_index=True</code> parameter ensures that the resulting
DataFrame has a new index assigned to the sorted rows, ignoring the
original index values. Many scenarios can be solved by sorting the
database by date. It allows for chronological analysis of the data, such
as tracking changes over time, identifying trends, or comparing
observations at different points in time.</p>
<p>After sorting, the DataFrame <code>TSLA</code> will have its rows
reordered based on the ascending order of the dates in the "Date"
column. This new order of rows can provide a clearer temporal
perspective on the dataset and facilitate subsequent analyses or
visualizations.</p>
<p>In summary,
<code>TSLA = TSLA.sort_values(by='Date', ignore_index=True)</code> sorts
the DataFrame <code>TSLA</code> in ascending order based on the values
in the "Date" column, resulting in a rearranged DataFrame that is
ordered chronologically.</p>
</div>
<div class="cell code" data-execution_count="16" id="5Or3Gr3BBPht">
<div class="sourceCode" id="cb17"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop rows having Date &lt; &#39;2015-01-01&#39;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>TSLA <span class="op">=</span> TSLA[TSLA[<span class="st">&quot;Date&quot;</span>] <span class="op">&gt;=</span> <span class="st">&#39;2015-01-01&#39;</span>].reset_index(drop <span class="op">=</span> <span class="va">True</span>)</span></code></pre></div>
</div>
<div class="cell markdown">
<p>This code removes rows from the DataFrame <code>TSLA</code> that have
a date earlier than January 1, 2015. With the pandas library,
conditional indexing and DataFrame manipulation are used. When the
"Date" column value is greater than or equal to '2015-01-01', the code
creates a new DataFrame that includes only those rows. In other words,
it filters out the rows that have dates before January 1, 2015. This
effectively removes any data points from earlier dates from the
resulting DataFrame. This can be useful when focusing on a specific time
period or when excluding outdated data from the analysis. It resets the
DataFrame's index after filtering. The <code>drop=True</code> parameter
ensures that the old index is not added as a new column in the
DataFrame.</p>
<p>In summary,
<code>TSLA = TSLA[TSLA["Date"] &gt;= '2015-01-01'].reset_index(drop=True)</code>
updates the DataFrame <code>TSLA</code> by removing rows that have dates
earlier than January 1, 2015. Filtering narrows down the dataset to
focus on a specific time period for analysis or visualization.</p>
</div>
<div class="cell code" data-execution_count="17"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:284}"
id="-t93vdN14TK0" data-outputId="f40e7fc9-2e7b-49e3-dfbd-60b72612222e">
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>TSLA.describe()</span></code></pre></div>
<div class="output execute_result" data-execution_count="17">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Open</th>
      <th>High</th>
      <th>Low</th>
      <th>Close</th>
      <th>Adj. Close</th>
      <th>Volume</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>1549.000000</td>
      <td>1549.000000</td>
      <td>1549.000000</td>
      <td>1549.000000</td>
      <td>1549.000000</td>
      <td>1.549000e+03</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>110.810891</td>
      <td>113.270362</td>
      <td>108.205281</td>
      <td>110.953628</td>
      <td>110.953628</td>
      <td>3.992077e+07</td>
    </tr>
    <tr>
      <th>std</th>
      <td>157.089086</td>
      <td>160.828238</td>
      <td>152.917803</td>
      <td>157.395272</td>
      <td>157.395272</td>
      <td>2.937944e+07</td>
    </tr>
    <tr>
      <th>min</th>
      <td>28.460000</td>
      <td>30.990000</td>
      <td>28.210000</td>
      <td>28.730000</td>
      <td>28.730000</td>
      <td>3.540000e+06</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>45.760000</td>
      <td>46.310000</td>
      <td>44.990000</td>
      <td>45.700000</td>
      <td>45.700000</td>
      <td>2.127200e+07</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>57.600000</td>
      <td>59.000000</td>
      <td>56.560000</td>
      <td>57.930000</td>
      <td>57.930000</td>
      <td>3.079200e+07</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>70.510000</td>
      <td>71.440000</td>
      <td>69.250000</td>
      <td>70.360000</td>
      <td>70.360000</td>
      <td>4.735750e+07</td>
    </tr>
    <tr>
      <th>max</th>
      <td>891.380000</td>
      <td>900.400000</td>
      <td>871.600000</td>
      <td>883.090000</td>
      <td>883.090000</td>
      <td>3.046940e+08</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<div class="cell markdown">
<p>This code computes and displays descriptive statistics for the
DataFrame <code>TSLA</code> using the <code>describe()</code> function
provided by the pandas library. The code returns a summary of
statistical measures for each numerical column. It includes statistics
such as counts, means, standard deviations, minimum values, quartiles,
and maximum values.</p>
<p>The purpose of calling <code>describe()</code> is to provide a quick
overview of the distribution and basic statistical properties of the
numerical data in the DataFrame. It helps in understanding the central
tendency, variability, and range of values in each column.</p>
<p>The summary statistics can be useful for identifying outliers,
detecting potential issues with the data (e.g., extreme values), and
getting a general sense of the dataset's distribution and
characteristics.</p>
<p>In summary, <code>TSLA.describe()</code> computes and presents
summary statistics for the numerical columns in the DataFrame
<code>TSLA</code>. Statistics provide insight into the distribution and
characteristics of data.</p>
</div>
<div class="cell markdown" id="G1TnSUJUWZjT">
<p>Analyzing exploratory data</p>
</div>
<div class="cell code" data-execution_count="39" id="TU5sBLoxHWWT">
<div class="sourceCode" id="cb19"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>Companies <span class="op">=</span> [AAPL, TSLA, GOOG, MSFT, AMZN]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>Companies_Title <span class="op">=</span> [<span class="st">&quot;Apple&quot;</span>, <span class="st">&quot;Tesla&quot;</span>, <span class="st">&quot;Google&quot;</span>, <span class="st">&quot;Microsoft&quot;</span>, <span class="st">&quot;Amazon&quot;</span>]</span></code></pre></div>
</div>
<div class="cell markdown">
<p>The code creates two lists: "Companies" and "Companies_Title".</p>
<p>"Companies" contains references to five different DataFrames: AAPL,
TSLA, GOOG, MSFT, and AMZN. Each DataFrame corresponds to the stock
market information of a specific company. In the "Companies_Title" list,
there are the names of the respective companies: Apple, Tesla, Google,
Microsoft, and Amazon. The order of the company names in the
"Companies_Title" list corresponds to the order of the DataFrames in the
"Companies" list. This makes it convenient to store and access multiple
DataFrames. The code allows for easy retrieval and manipulation of the
DataFrames and their corresponding titles during subsequent analysis or
visualization tasks.</p>
<p>In summary, the code creates two lists: "Companies" and
"Companies_Title", which store references to DataFrames representing
different companies' stock market data and their corresponding company
names, respectively. For further analysis, these lists facilitate the
organization and retrieval of data.</p>
</div>
<div class="cell code" data-execution_count="40"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:716}"
id="Txroq1_o-tvd" data-outputId="dec52472-2c9e-42c2-b7b7-65ae9beed2a2">
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Lets view historical view of the closing prices</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">12</span>))</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> index, company <span class="kw">in</span> <span class="bu">enumerate</span>(Companies):</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  plt.subplot(<span class="dv">3</span>, <span class="dv">2</span>, index <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>  plt.plot(company[<span class="st">&quot;Date&quot;</span>], company[<span class="st">&quot;Adj. Close&quot;</span>])</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>  plt.title(Companies_Title[index])</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>  plt.ylabel(<span class="st">&#39;Adj. Close&#39;</span>)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_36c5110a6cb1437fadd59d29e1cab87a/fec73e4d5723f7ef9da0037f5b17d6ce1fabc3d0.png" /></p>
</div>
</div>
<div class="cell markdown">
<p>A visual representation of historical closing prices for a set of
companies is generated using this code. It utilizes the
matplotlib.pyplot library for creating plots. The code specifies the
plot size as 20 units in width and 12 units in height by specifying
plot.figure(figsize=(20, 12)). This ensures that the resulting plot is
large enough to display the historical price data for all companies
clearly. It then loops over each company in the "Companies" list. It
creates a subplot for each company using plt.subplot(3, 2, index + 1).
This arranges the subplots in a grid of 3 rows and 2 columns, with the
index + 1 determining the position of the current subplot. The code
plots each company's historical closing price within each subplot. Using
<code>plt.plot(company["Date"], company["Adj. Close"])</code> to create
a line plot with the dates on the x-axis and the adjusted closing prices
on the y-axis.</p>
<p>Additionally, the code sets the title of each subplot to the
corresponding company's name using
<code>plt.title(Companies_Title[index])</code>, and it labels the y-axis
as "Adj. Then close it with <code>plt.ylabel('Adj. Close')</code>. Each
subplot shows the historical closing prices of a different company. This
visualization allows for a visual comparison of the closing price trends
over time for the selected companies. To summarize, the code creates a
multi-plot figure to display historical closing prices for multiple
companies. The program generates line plots for each company, arranges
them in a grid, and labels each subplot with the name of that company.
Comparing closing price trends between companies is made easier with
this visualization.</p>
</div>
<div class="cell markdown" id="-EYsfC9dfbHd">
<p>We can see from the above graph that Telsa shares have tremendous
growth in the 2020-2021 period. According to the news, this may be due
to 1. Sales of emission credits 2. 3. Tesla enters the fast-growing
compact SUV market. Starting production in China COVID-19 is the primary
factor affecting the 2020-2021 period for the rest of the companies.</p>
</div>
<div class="cell code" data-execution_count="41"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:716}"
id="T_7QBBszJZdD" data-outputId="1fdef202-33ea-4127-f460-9d6172a7130b">
<div class="sourceCode" id="cb21"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Now lets plot the total volume of stock being traded each day </span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">12</span>))</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> index, company <span class="kw">in</span> <span class="bu">enumerate</span>(Companies):</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  plt.subplot(<span class="dv">3</span>, <span class="dv">2</span>, index <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  plt.plot(company[<span class="st">&quot;Date&quot;</span>], company[<span class="st">&quot;Volume&quot;</span>])</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  plt.title(Companies_Title[index])</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>  plt.ylabel(<span class="st">&#39;Volume&#39;</span>)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_36c5110a6cb1437fadd59d29e1cab87a/a632e45123425cd3ec485dbacc775d199d6f23f8.png" /></p>
</div>
</div>
<div class="cell markdown">
<p>A visual representation of the total volume of stocks traded each day
for a set of companies is generated by this code. It uses the
matplotlib.pyplot library for creating plots. The code specifies that
the figure's size is 20 units in width and 12 units in height. This
ensures that the resulting plot is large enough to display the volume
data for all companies clearly. Next, the "Companies" list is iterated
over. A subplot is created for each company using
<code>plt.subplot(3, 2, index + 1)</code>. The code arranges the
subplots in a grid of 3 rows and 2 columns, with the index + 1
determining the position of the current subplot. For each subplot, the
code plots the total volume of stocks traded each day. It uses
<code>plt.plot(company["Date"], company["Volume"])</code> to create a
line plot with the dates on the x-axis and the volume of stocks traded
on the y-axis.</p>
<p>Additionally, the code sets the title of each subplot to the
corresponding company's name using
<code>plt.title(Companies_Title[index])</code>, and it labels the y-axis
as "Volume" with <code>plt.ylabel('Volume')</code>.</p>
<p>The result is a grid of subplots, each displaying the daily total
volume of stocks traded for a different company. This visualization
allows for a visual comparison of the volume trends over time for the
selected companies. Basically, the code displays the total volume of
stocks traded each day for multiple companies in a multi-plot. Line
plots are generated for each company, arranged in a grid, and labelled
with their names. Comparing the volume trends of different companies is
made easier with this visualization.</p>
</div>
<div class="cell markdown" id="RPEReM4fhBsj">
<p>The closing price and volume traded each day have been visualized, so
let's calculate the stock's moving average.</p>
</div>
<div class="cell markdown" id="dMJUuA_GlYke">
<p>What is the moving average of the various stocks?</p>
</div>
<div class="cell code" data-execution_count="42" id="dQ2TZ-0uLJRh">
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>Moving_Average_Day <span class="op">=</span> [<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">50</span>]</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> Moving_Average <span class="kw">in</span> Moving_Average_Day:</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> company <span class="kw">in</span> Companies:</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    column_name <span class="op">=</span> <span class="ss">f&#39;Moving Average for </span><span class="sc">{</span>Moving_Average<span class="sc">}</span><span class="ss"> days&#39;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    company[column_name] <span class="op">=</span> company[<span class="st">&quot;Adj. Close&quot;</span>].rolling(Moving_Average).mean()</span></code></pre></div>
</div>
<div class="cell markdown">
<p>For the "Adj" variable, this code calculates moving averages for a
specified number of days. Each DataFrame in the "Companies" list has a
"Close" column. A nested loop is used to iterate over a list of moving
average values and a list of companies. "Moving_Average_Day" is a list
that contains the desired moving average values, such as 10, 20, and 50.
Each moving average value in "Moving_Average_Day" is then iterated over
in the outer loop. For each moving average value, the inner loop
iterates over each company in the "Companies" list. The inner loop
calculates the moving average using the rolling().mean() function. The
"Adj" variable is affected by this function. Close" column of each
company's DataFrame, and it computes the average of the preceding values
over the specified number of days. Moving average values are stored in a
new column in each company's DataFrame. According to the moving average
value, this column is named dynamically, such as "Moving Average for 10
days", "Moving Average for 20 days", etc.</p>
<p>The result is that for each company, new columns are added to their
DataFrame, containing the calculated moving average values for the
specified number of days. These moving average values can be used to
analyze trends and patterns in the stock prices over time. To summarize,
moving average values are calculated and added to each company's
DataFrame. These averages are computed for the "Adj.". In the newly
created columns, they are stored in the "Close" column. As a result, the
data can be further analyzed and trends in stock prices can be
identified.</p>
</div>
<div class="cell code" data-execution_count="43"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:716}"
id="KuMDzBetNwbo" data-outputId="42f1d759-41f1-448b-99e6-9333468c27fd">
<div class="sourceCode" id="cb23"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">12</span>))</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> index, company <span class="kw">in</span> <span class="bu">enumerate</span>(Companies):</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  plt.subplot(<span class="dv">3</span>, <span class="dv">2</span>, index <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  plt.plot(company[<span class="st">&quot;Date&quot;</span>], company[<span class="st">&quot;Adj. Close&quot;</span>])</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  plt.plot(company[<span class="st">&quot;Date&quot;</span>], company[<span class="st">&quot;Moving Average for 10 days&quot;</span>])</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  plt.plot(company[<span class="st">&quot;Date&quot;</span>], company[<span class="st">&quot;Moving Average for 20 days&quot;</span>])</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  plt.plot(company[<span class="st">&quot;Date&quot;</span>], company[<span class="st">&quot;Moving Average for 50 days&quot;</span>])</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>  plt.title(Companies_Title[index])</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>  plt.legend((<span class="st">&quot;Adj. Close&quot;</span>, <span class="st">&quot;Moving Average for 10 days&quot;</span>, <span class="st">&quot;Moving Average for 20 days&quot;</span>, <span class="st">&quot;Moving Average for 50 days&quot;</span>))</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_36c5110a6cb1437fadd59d29e1cab87a/70805b9c4f069da2bef41f6f73a70711bdbf83e3.png" /></p>
</div>
</div>
<div class="cell markdown">
<p>For a set of companies, this code plots the adjusted closing prices
and the moving averages for different number of days. It uses the
matplotlib.pyplot library for creating plots. With the
plt.figure(figsize=(20, 12))() method, the plot is set to 20 units wide
by 12 units high. This ensures that the resulting plot is large enough
to display the data for all companies clearly. A loop iterates over each
company in the list. In each company, a subplot is created using
plt.subplot(3, 2, index + 1). The subplots are arranged in a grid with 3
rows and 2 columns, with the current subplot positioned at index + 1.
The code plots multiple lines for different numbers of days to represent
the adjusted closing prices and moving average values for each subplot.
Using plt.plot(), it creates line plots with dates on the x-axis and the
corresponding values on the y-axis. There are four lines, which
represent adjusted closing prices, a 10-day moving average, a 20-day
moving average, and a 50-day moving average.</p>
<p>Additionally, the code sets the title of each subplot to the
corresponding company's name using
<code>plt.title(Companies_Title[index])</code>. It also adds a legend to
each subplot using <code>plt.legend()</code> to label the different
lines in the plot. This produces a grid of subplots, each displaying the
adjusted closing prices and multiple moving average lines. With this
visualization, you can see how stock prices and moving averages have
changed over time for the selected companies. The code displays the
adjusted closing prices and moving average values for multiple companies
for different numbers of days in a multi-plot figure. The program
creates line plots for each company, arranges them in a grid, and adds
titles and legends. Different companies' stock price trends and moving
average trends can be compared with this visualization.</p>
</div>
<div class="cell markdown" id="lUkLurJamh4Q">
<p>On average, what was the stock's daily return?</p>
</div>
<div class="cell markdown" id="Y6tPCkdZmzdX">
<p>Let's dive a little deeper now that we've done some baseline
analysis. The stock's risk will now be analyzed. Rather than just
looking at the stock's absolute value, we need to consider the stock's
daily changes.</p>
</div>
<div class="cell code" data-execution_count="44" id="GqU9sJhkOuF6">
<div class="sourceCode" id="cb24"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># pct_change() function calculates the percentage change between the current and a prior element.</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="co"># This function by default calculates the percentage change from the immediately previous row. </span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> company <span class="kw">in</span> Companies:</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  company[<span class="st">&quot;Daily Return&quot;</span>] <span class="op">=</span> company[<span class="st">&quot;Adj. Close&quot;</span>].pct_change()</span></code></pre></div>
</div>
<div class="cell markdown">
<p>The "Companies" list is used to calculate daily returns for each
company's adjusted closing price. It uses the <code>pct_change()</code>
function provided by the pandas library. Each company in the list is
iterated over. In each company, the pct_change() function is applied to
the "Adj." field. Close" column of the company's DataFrame. By default,
the pct_change() function calculates the percentage difference between
the current element and the previous element. In this case, it
calculates the percentage change between each day's adjusted closing
price and the adjusted closing price of the previous day. For each
company, a column called "Daily Return" is created. This column
represents the percentage change in the adjusted closing price from one
day to the next. A new column containing the daily return values is
added to each company's DataFrame. These values provide insights into
the daily price movements and the rate of return for each company's
stock. To summarize, the code calculates and adds the daily return
values to each DataFrame. Based on the percentage change in adjusted
closing prices, these values are calculated. As a result, it is possible
to analyze the daily price movements and the performance of the stocks
in more detail.</p>
</div>
<div class="cell code" data-execution_count="45"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:716}"
id="ndGIffSkPCSX" data-outputId="c1566458-d0e0-46b0-8aaf-94fada925b16">
<div class="sourceCode" id="cb25"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">12</span>))</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> index, company <span class="kw">in</span> <span class="bu">enumerate</span>(Companies):</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  plt.subplot(<span class="dv">3</span>, <span class="dv">2</span>, index <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  plt.plot(company[<span class="st">&quot;Date&quot;</span>], company[<span class="st">&quot;Daily Return&quot;</span>])</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  plt.title(Companies_Title[index])</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  plt.ylabel(<span class="st">&#39;Daily Return&#39;</span>)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_36c5110a6cb1437fadd59d29e1cab87a/83c70538ce1d163f8b261311bd4f07957434693a.png" /></p>
</div>
</div>
<div class="cell markdown">
<p>The code generates a plot of daily returns for a set of companies. It
uses the matplotlib.pyplot library for creating plots. As indicated in
the code, the plot size is 20 units wide and 12 units high. This ensures
that the resulting plot is large enough to display the data for all
companies clearly. After that, a loop iterates over each company. Using
plt.subplot(3, 2, index + 1), it creates a subplot for each company.
This arranges the subplots in a grid of 3 rows and 2 columns, with the
index + 1 determining the position of the current subplot. The code
plots the daily returns for each company within each subplot. It uses
<code>plt.plot(company["Date"], company["Daily Return"])</code> to
create a line plot with the dates on the x-axis and the daily return
values on the y-axis.</p>
<p>Additionally, the code sets the title of each subplot to the
corresponding company's name using
<code>plt.title(Companies_Title[index])</code>, and it labels the y-axis
as "Daily Return" with <code>plt.ylabel('Daily Return')</code>.</p>
<p>The result is a grid of subplots, each displaying the daily returns
for a different company. This visualization allows for a comparison of
the daily performance and volatility of the selected companies' stocks.
The code creates a multi-plot figure that displays multiple company
returns daily. Line plots for each company are generated, arranged in a
grid, and labelled with the company names. In this visualization, you
can compare the daily performance and volatility of different stocks of
different companies.</p>
</div>
<div class="cell markdown" id="7ian-g3OoUDa">
<p>Here's a histogram of the average daily return.</p>
</div>
<div class="cell code" data-execution_count="46"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:893}"
id="aCZZHoWjPWwo" data-outputId="2bcc8e77-494c-4be4-e9b5-9fcf07da7156">
<div class="sourceCode" id="cb26"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># distplot is a deprecated function, so to ignore warnings, the filterwarnings function is used.</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">&#39;ignore&#39;</span>)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">15</span>))</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> index, company <span class="kw">in</span> <span class="bu">enumerate</span>(Companies):</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>  plt.subplot(<span class="dv">3</span>, <span class="dv">2</span>, index <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>  sns.distplot(company[<span class="st">&quot;Daily Return&quot;</span>].dropna(), color <span class="op">=</span> <span class="st">&quot;purple&quot;</span>)</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>  plt.title(Companies_Title[index])</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_36c5110a6cb1437fadd59d29e1cab87a/161b6314ec8483dcdab49dfaec507630976fc113.png" /></p>
</div>
</div>
<div class="cell markdown">
<p>For a set of companies, this code generates distribution plots for
their daily returns. It uses the seaborn library's
<code>distplot()</code> function to create the distribution plots. In
order to deal with any warnings associated with the old displot()
method, the code uses the warnings module and the filterwarnings()
method. By calling <code>warnings.filterwarnings('ignore')</code>, the
code instructs the program to ignore any warning messages that may arise
during the execution.</p>
<p>By specifying <code>plt.figure(figsize=(20, 15))</code>, the code
sets the size of the figure, or the overall plot, to 20 units in width
and 15 units in height. This ensures that the resulting plots are large
enough to display the distributions for all companies clearly. In the
loop, each company in the "Companies" list is iterated over. Each
company's subplot is created using plt.subplot(3, 2, index + 1). This
arranges the subplots in a grid of 3 rows and 2 columns, with the index
+ 1 determining the position of the current subplot. The code plots the
distribution of daily returns for each company within each subplot. This
plot uses sns.distplot(company["Daily Return"].dropna(), color="purple")
to create an image that looks like a histogram. The
<code>dropna()</code> function is used to remove any missing values from
the "Daily Return" column before plotting.</p>
<p>Additionally, the code sets the title of each subplot to the
corresponding company's name using
<code>plt.title(Companies_Title[index])</code>.</p>
<p>The result is a grid of subplots, each displaying the distribution
plot for the daily returns of a different company. This visualization
allows for a comparison of the distributions and characteristics of the
daily returns across the selected companies. The code creates a
multi-plot figure that displays the distribution of the daily returns
for multiple companies. This function generates distribution plots using
the deprecated <code>distplot()</code> function from the seaborn
library. As a result, the code ignores any related warnings and arranges
the subplots in a grid with the company names labeled. Different
companies' daily returns can be compared using this visualization.</p>
</div>
<div class="cell markdown" id="hB1sENYBGY1u">
<p>Kurtosis refers to the difference between the tails of a distribution
and the tails of a normal distribution. The kurtosis of a distribution
indicates whether its tails contain extreme values.</p>
</div>
<div class="cell code" data-execution_count="47"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}"
id="9Nr7ExXjB1ng" data-outputId="33ddf578-86fa-45ac-c6a2-a623e26126e7">
<div class="sourceCode" id="cb27"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Kurtosis Value&quot;</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> index, company <span class="kw">in</span> <span class="bu">enumerate</span>(Companies):</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f&#39;</span><span class="sc">{</span>Companies_Title[index]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>company[<span class="st">&quot;Daily Return&quot;</span>]<span class="sc">.</span>kurtosis()<span class="sc">}</span><span class="ss">&#39;</span>)</span></code></pre></div>
<div class="output stream stdout">
<pre><code>Kurtosis Value
Apple: 6.405686938843391
Tesla: 5.764945983385828
Google: 10.086026546409723
Microsoft: 10.603491741447666
Amazon: 7.135284710744968
</code></pre>
</div>
</div>
<div class="cell markdown">
<p>For a set of companies, this code calculates and prints the kurtosis
values. It uses the <code>kurtosis()</code> function provided by the
pandas library. The code begins by printing the header "Kurtosis Value"
to indicate the information being displayed. After that, a loop iterates
over each company in the "Companies" list. For each company, it
calculates the kurtosis value of the daily returns using
<code>company["Daily Return"].kurtosis()</code>. Kurtosis quantifies the
shape of a distribution. Compared to the normal distribution, it
indicates whether the distribution has a sharp or flat peak. Positive
kurtosis indicates a more peaked distribution with heavier tails, while
negative kurtosis indicates a flatter distribution with lighter tails. A
value of 0 indicates a distribution similar to the normal distribution.
The loop prints the company name along with the kurtosis value using
print(f'[Companies_Title[index]]: [company["Daily
Return"].kurtosis()]'). This displays the kurtosis value for each
company. It prints the kurtosis values for each company's daily returns.
This information provides insights into the shape and characteristics of
the distribution of daily returns for each company's stock. The code
calculates and prints kurtosis values for multiple stocks. The function
iterates over each company, calculates the kurtosis value using the
kurtosis() function, and displays the company name along with the
kurtosis value. Understanding the distribution characteristics of
different companies' daily returns is made easier with this
information.</p>
</div>
<div class="cell markdown" id="rlKuy38GAqbk">
<p>According to the above graph and the positive kurtosis value, it is
rare to get extreme daily return values.</p>
</div>
<div class="cell markdown" id="ekiyGKRkqJrP">
<p>What was the correlation between the closing prices of different
stocks?</p>
</div>
<div class="cell code" data-execution_count="48"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:195}"
id="cACinU88P-w0" data-outputId="3b48c692-94f0-49d4-c55f-ca701929571c">
<div class="sourceCode" id="cb29"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Companies_return contain closing price of all the companies</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>Companies_returns <span class="op">=</span> pd.DataFrame()</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>Companies_returns[<span class="st">&quot;AAPL&quot;</span>] <span class="op">=</span> AAPL[<span class="st">&quot;Adj. Close&quot;</span>]</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>Companies_returns[<span class="st">&quot;TSLA&quot;</span>] <span class="op">=</span> TSLA[<span class="st">&quot;Adj. Close&quot;</span>]</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>Companies_returns[<span class="st">&quot;GOOG&quot;</span>] <span class="op">=</span> GOOG[<span class="st">&quot;Adj. Close&quot;</span>]</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>Companies_returns[<span class="st">&quot;MSFT&quot;</span>] <span class="op">=</span> MSFT[<span class="st">&quot;Adj. Close&quot;</span>]</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>Companies_returns[<span class="st">&quot;AMZN&quot;</span>] <span class="op">=</span> AMZN[<span class="st">&quot;Adj. Close&quot;</span>]</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>Companies_returns.head()</span></code></pre></div>
<div class="output execute_result" data-execution_count="48">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>AAPL</th>
      <th>TSLA</th>
      <th>GOOG</th>
      <th>MSFT</th>
      <th>AMZN</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>24.86</td>
      <td>43.86</td>
      <td>523.37</td>
      <td>41.44</td>
      <td>308.52</td>
    </tr>
    <tr>
      <th>1</th>
      <td>24.16</td>
      <td>42.02</td>
      <td>512.46</td>
      <td>41.06</td>
      <td>302.19</td>
    </tr>
    <tr>
      <th>2</th>
      <td>24.16</td>
      <td>42.26</td>
      <td>500.59</td>
      <td>40.46</td>
      <td>295.29</td>
    </tr>
    <tr>
      <th>3</th>
      <td>24.50</td>
      <td>42.19</td>
      <td>499.73</td>
      <td>40.97</td>
      <td>298.42</td>
    </tr>
    <tr>
      <th>4</th>
      <td>25.44</td>
      <td>42.12</td>
      <td>501.30</td>
      <td>42.18</td>
      <td>300.46</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<div class="cell markdown">
<p>It creates a DataFrame called "Companies_returns" that contains the
adjusted closing prices of multiple companies. The code first creates an
empty DataFrame called "Companies_returns" to store the adjusted closing
prices of the companies. It then manipulates and combines data from
individual DataFrames. After that, the adjusted closing prices of each
company are assigned to their respective columns in the
"Companies_returns" DataFrame. "Companies_returns" assigns the values
from the "Adj" column to the "AAPL" column. The "Close" column in the
"AAPL" DataFrame. Each company is repeated, including "TSLA", "GOOG",
"MSFT", and "AMZN". The "Companies_returns" DataFrame provides a
consolidated view of the closing prices of the selected companies by
combining the adjusted closing prices from the individual company
DataFrames. In summary, this code creates a "Companies_returns.head()"
statement, which displays the first few rows of the "Companies_returns"
DataFrame, showing the adjusted closing prices of the companies.
"Companies_returns" is a new DataFrame that consolidates the adjusted
closing prices of multiple companies. This DataFrame combines the
closing prices from individual company DataFrames and displays the first
few rows of the consolidated DataFrame. As a result, the closing prices
of the selected companies can easily be compared and analyzed.</p>
</div>
<div class="cell code" data-execution_count="49"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:195}"
id="DH_kK5CjR89D" data-outputId="c4e554a8-6cb4-482a-98c6-bee315dc4941">
<div class="sourceCode" id="cb30"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Companies_Daily_returns contains percentage daily returns of all the companies</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>Companies_Daily_returns <span class="op">=</span> Companies_returns.pct_change()</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>Companies_Daily_returns.head()</span></code></pre></div>
<div class="output execute_result" data-execution_count="49">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>AAPL</th>
      <th>TSLA</th>
      <th>GOOG</th>
      <th>MSFT</th>
      <th>AMZN</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-0.028158</td>
      <td>-0.041952</td>
      <td>-0.020846</td>
      <td>-0.009170</td>
      <td>-0.020517</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.000000</td>
      <td>0.005712</td>
      <td>-0.023163</td>
      <td>-0.014613</td>
      <td>-0.022833</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.014073</td>
      <td>-0.001656</td>
      <td>-0.001718</td>
      <td>0.012605</td>
      <td>0.010600</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.038367</td>
      <td>-0.001659</td>
      <td>0.003142</td>
      <td>0.029534</td>
      <td>0.006836</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<div class="cell markdown">
<p>DataFrame "Companies_returns" contains the percentage daily returns
for each company. It uses the <code>pct_change()</code> function
provided by the pandas library. It starts by creating a new DataFrame
called "Companies_Daily_returns" to store the calculated percentage
daily returns. It next applies the <code>pct_change()</code> function to
the "Companies_returns" DataFrame. This function calculates the
percentage change between each element and the previous element in the
DataFrame. It uses the Companies_returns DataFrame to calculate
percentage daily returns for each company column. In this case, the
daily rate of change is expressed as a percentage. A head() statement
displays the first few rows of the "Companies_Daily_returns" DataFrame,
which includes the calculated percentage daily returns for each company.
The code calculates and creates a new DataFrame called
"Companies_Daily_returns" that contains the daily percentage returns for
each company in "Companies_returns". This dataframe provides insight
into the daily return patterns of the selected companies using the
pct_change() function.</p>
</div>
<div class="cell markdown" id="DSq4s7Q_s19N">
<p>In order to get actual numerical values for the correlation between
the closing prices of the stocks, let's plot a correlation plot</p>
</div>
<div class="cell code" data-execution_count="50"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:286}"
id="xd_uqJfNTEOD" data-outputId="041e9961-bf53-4d21-94d5-b5aa6a941f71">
<div class="sourceCode" id="cb31"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>sns.heatmap(Companies_returns.corr(), annot<span class="op">=</span><span class="va">True</span>, cmap<span class="op">=</span><span class="st">&quot;YlGnBu&quot;</span>)</span></code></pre></div>
<div class="output execute_result" data-execution_count="50">
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7fc9aca54fd0&gt;</code></pre>
</div>
<div class="output display_data">
<p><img
src="vertopal_36c5110a6cb1437fadd59d29e1cab87a/0a339e1572dcd19f92184e1edb191667e8d789c4.png" /></p>
</div>
</div>
<div class="cell markdown">
<p>A heatmap plot is generated to visualize the correlation matrix of
the "Companies_returns" DataFrame. It uses the seaborn library's
<code>heatmap()</code> function. It first computes the correlation
coefficients between all pairs of columns in the "Companies_returns"
DataFrame. The resulting correlation matrix represents the relationships
between the closing prices of different companies. This code then
generates a heatmap plot where each cell represents the correlation
between two columns. The intensity of the color in each cell indicates
the strength and direction of the correlation. The
<code>annot=True</code> parameter enables the display of the correlation
values within each cell of the heatmap, providing additional information
about the correlation coefficients. The <code>cmap="YlGnBu"</code>
parameter sets the color map for the heatmap, specifying the color
gradient to be used. The resulting heatmap visually represents the
correlation matrix, allowing for a quick overview of the relationships
Different companies' closing prices. In general, positive correlations
are represented by brighter colors, indicating a direct relationship,
while negative correlations are represented by darker colors, indicating
an inverse relationship. This code visualizes the correlation matrix of
closing prices of different companies in the "Companies_returns"
DataFrame using a heatmap plot. This heatmap shows the relationships and
dependencies between the stock prices of selected companies.</p>
</div>
<div class="cell markdown" id="xYoMurRktMUf">
<p>Let's do a correlation plot to get actual numerical values for the
correlation between the stocks' daily returns.</p>
</div>
<div class="cell code" data-execution_count="51"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:286}"
id="uBLA3r3iT8xe" data-outputId="729bd305-4deb-4942-8acf-9ffcf379fae5">
<div class="sourceCode" id="cb33"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>sns.heatmap(Companies_Daily_returns.corr(), annot<span class="op">=</span><span class="va">True</span>, cmap<span class="op">=</span><span class="st">&quot;YlGnBu&quot;</span>)</span></code></pre></div>
<div class="output execute_result" data-execution_count="51">
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7fc9a4173650&gt;</code></pre>
</div>
<div class="output display_data">
<p><img
src="vertopal_36c5110a6cb1437fadd59d29e1cab87a/20e75e71c2725b02f1a6c8b894360ccc5e70ebff.png" /></p>
</div>
</div>
<div class="cell markdown">
<p>To visualize the correlation matrix of the "Companies_Daily_returns"
DataFrame, this code generates a heatmap plot. It uses the seaborn
library's <code>heatmap()</code> function. It first calls
Companies_Daily_Returns.corr() to compute correlation coefficients
between all pairs of columns in the "Companies_Daily_Returns" DataFrame.
The resulting correlation matrix represents the relationships between
the percentage daily returns of different companies. The code generates
a heatmap plot with each cell representing the correlation between two
columns. The intensity of the color in each cell indicates the strength
and direction of the correlation. The <code>annot=True</code> parameter
enables the display of the correlation values within each cell of the
heatmap, providing additional information about the correlation
coefficients. The <code>cmap="YlGnBu"</code> parameter sets the color
map for the heatmap, specifying the color gradient to be used. The
resulting heatmap visually represents the correlation matrix, allowing
for a quick overview of the relationships Different companies have
different percentage daily returns. A positive correlation is typically
represented by brighter colors, indicating a direct relationship,
whereas a negative correlation is represented by darker colors,
indicating an inverse relationship. To visualize the correlation matrix
of percentage daily returns of different companies in the
"Companies_Daily_returns" DataFrame, this code generates a heatmap plot.
This heatmap illustrates the relationships and dependencies between the
daily return patterns of the selected companies.</p>
</div>
<div class="cell markdown" id="IAKbeVcnrtxA">
<p>Microsoft and Google had the strongest correlation in stock returns,
based on the above plot.</p>
</div>
<div class="cell markdown" id="0vM1L-cJxbRU">
<p>By investing in a particular stock, how much value are we putting at
risk?</p>
</div>
<div class="cell markdown" id="gklKhUQCyfvG">
<p>By comparing the expected return with the standard deviation of the
daily returns, we can quantify risk using the information we have
gathered on daily percentage returns.</p>
</div>
<div class="cell code" data-execution_count="52"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:334}"
id="23Ja7rQfUSJO" data-outputId="b2b20f2b-577f-42be-bfc3-da195bbe36a7">
<div class="sourceCode" id="cb35"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>Returns <span class="op">=</span> Companies_Daily_returns.dropna()</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">5</span>))</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>plt.scatter(Returns.mean(), Returns.std())</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Expected return&#39;</span>)</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Risk&#39;</span>)</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label, x, y <span class="kw">in</span> <span class="bu">zip</span>(Companies_Title, Returns.mean(), Returns.std()):</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    plt.annotate(label, xy <span class="op">=</span> (x, y), xytext <span class="op">=</span> (<span class="dv">10</span>, <span class="dv">0</span>), textcoords <span class="op">=</span> <span class="st">&#39;offset points&#39;</span>)</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_36c5110a6cb1437fadd59d29e1cab87a/274dbe8a9a52e16d62ab4de852c900dc94346d9f.png" /></p>
</div>
</div>
<div class="cell markdown">
<p>The code generates a scatter plot to visualize the relationship
between expected return and risk. It uses the matplotlib.pyplot library
for creating the scatter plot. It first drops any rows with missing
values from the "Companies_Daily_returns" DataFrame. This ensures that
the data used for the scatter plot is complete. The code specifies that
the figure, or the overall plot, is 20 units wide and 5 units high. This
ensures that the resulting scatter plot is large enough to display the
data clearly. The scatter plot is then plotted using
plt.scatter(Returns.mean(), Returns.std()). The x-coordinates are the
mean values of the returns and the y-coordinates are the standard
deviation values. On a scatter plot, each point represents a company,
and its position indicates how the expected return relates to the risk
for that company.</p>
<p>Additionally, the code sets the x-axis label as "Expected return"
with <code>plt.xlabel('Expected return')</code> and the y-axis label as
"Risk" with <code>plt.ylabel('Risk')</code>. This provides clear labels
for the scatter plot axes. Moreover, each point on the scatter plot is
annotated with the company name via a loop. In addition to adding text
labels to each scatter plot point, it iterates over the company names,
the mean values, and the standard deviation values. A scatter plot is
generated which illustrates the correlation between the expected return
and risk for the selected companies. Companies with different
risk-return profiles can be identified and insights into the trade-off
between risk and expected return can be gained. For multiple companies,
the code generates a scatter plot to visualize the relationship between
return and risk. It plots the mean and standard deviation of the
returns, labels the axes, and annotates each point with the name of the
company. The visualization helps analyze different companies' risk and
return characteristics.</p>
</div>
<div class="cell markdown" id="oGONmkHF0DTf">
<p>According to the above graph, Tesla has the highest expected returns
and the highest risk factor. The lowest expected returns and the lowest
risk factor are associated with Google.</p>
</div>
</body>
</html>
